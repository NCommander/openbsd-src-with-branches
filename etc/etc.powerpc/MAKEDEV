#!/bin/sh -
#       $OpenBSD: MAKEDEV,v 1.12 1997/09/16 06:01:03 deraadt Exp $
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Written and contributed by W. Jolitz 12/90
#
# Redistribution and use in source and binary forms are permitted provided
# that: (1) source distributions retain this entire copyright notice and
# comment, and (2) distributions including binaries display the following
# acknowledgement:  ``This product includes software developed by the
# University of California, Berkeley and its contributors'' in the
# documentation or other materials provided with the distribution and in
# all advertising materials mentioning features or use of this software.
# Neither the name of the University nor the names of its contributors may
# be used to endorse or promote products derived from this software without
# specific prior written permission.
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
#	from: @(#)MAKEDEV	5.2 (Berkeley) 6/22/90
#	$NetBSD: MAKEDEV,v 1.17 1996/02/03 15:02:42 briggs Exp $
#
# Device "make" file.  Valid arguments:
#	all	a smattering--at least one of each except
#		fd* (unimp.) and ch*
#
#	std	standard devices
#	fd	file descriptor device nodes
#	local	configuration specific devices
#	raminst	for RAM disk install
#
# Tapes:
#	st*	scsi tapes
#
# Disks:
#	fd*	floppy disk drives (3 1/2") (unimp.)
#	sd*	SCSI disks
#	cd*	SCSI compact discs
#	ch*	SCSI changers
#	vnd*	vnode pseudo-disks
#	rd*	"ramdisk" pseudo-disks
#	ccd*	concatenated disk driver
#
# Terminal ports:
#	ttye*	ite consoles
#	tty*	standard built-in serial ports (2)
#
# Pseudo terminals:
#	pty*	set of 16 master and slave pseudo terminals
#
# Graphics devices:
#	grf*	Bitmapped graphics device
#
# Special purpose devices:
#	bpf*	packet filter
#	tun*	network tunnel driver
#	lkm	Device to for loadable kernel modules
#

PATH=/sbin:/bin/:/usr/bin:/usr/sbin
umask 77

hex ()
{
	case $1 in
		[0-9]) echo -n $1 ;;
		10) echo -n a;;
		11) echo -n b;;
		12) echo -n c;;
		13) echo -n d;;
		14) echo -n e;;
		15) echo -n f;;
	esac
}

for i
do
case $i in

all)
	sh MAKEDEV std fd
	sh MAKEDEV sd0 sd1 sd2 sd3 st0 st1 cd0 cd1
	sh MAKEDEV vnd0 vnd1 vnd2 vnd3
	sh MAKEDEV ccd0 ccd1 ccd2 ccd3
	sh MAKEDEV rd0
	sh MAKEDEV tty00 tty01 pty0
	sh MAKEDEV bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 bpf8 bpf9
	sh MAKEDEV tun0 tun1 tun2 tun3
	sh MAKEDEV lkm
	sh MAKEDEV local
	;;

ramdisk)
	sh MAKEDEV std
	sh MAKEDEV sd0 sd1 sd2 sd3 sd4 st0 st1 cd0 cd1
	sh MAKEDEV rd0
	sh MAKEDEV tty00 tty01 pty0
	;;

std)
	rm -f console drum kmem mem reload zero null tty
	rm -f klog stdin stdout stderr
	mknod console		c 0 0
	mknod drum		c 3 0	; chmod 640 drum ; chgrp kmem drum
	mknod kmem		c 2 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 2 0	; chmod 640 mem ; chgrp kmem mem
	mknod reload		c 2 20	; chmod 640 reload ; chgrp kmem reload
	mknod zero		c 2 12	; chmod 666 zero
	mknod null		c 2 2	; chmod 666 null
	mknod tty		c 1 0	; chmod 666 tty
	mknod klog		c 6 0	; chmod 600 klog
	mknod stdin		c 21 0	; chmod 666 stdin
	mknod stdout		c 21 1	; chmod 666 stdout
	mknod stderr		c 21 2	; chmod 666 stderr
	;;

fd)
	rm -f fd/*
	mkdir fd > /dev/null 2>&1
	n=0
	(cd fd && while [ $n -lt 64 ]; do mknod $n c 21 $n; n="$(( $n + 1 ))"; done)
	chown -R root.wheel fd
	chmod 555 fd
	chmod 666 fd/*
	;;

sd*|ccd*)
	umask 2 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
	case $i in
	sd*) name=sd; blk=2; chr=8;;
	ccd*) name=ccd; blk=16; chr=18;;
	esac
	rm -f $name$unit? r$name$unit?
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}a	b $blk `expr $unit '*' 16 + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 16 + 1`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 16 + 2`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 16 + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 16 + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 16 + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 16 + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 16 + 7`
		mknod ${name}${unit}i	b $blk `expr $unit '*' 16 + 8`
		mknod ${name}${unit}j	b $blk `expr $unit '*' 16 + 9`
		mknod ${name}${unit}k	b $blk `expr $unit '*' 16 + 10`
		mknod ${name}${unit}l	b $blk `expr $unit '*' 16 + 11`
		mknod ${name}${unit}m	b $blk `expr $unit '*' 16 + 12`
		mknod ${name}${unit}n	b $blk `expr $unit '*' 16 + 13`
		mknod ${name}${unit}o	b $blk `expr $unit '*' 16 + 14`
		mknod ${name}${unit}p	b $blk `expr $unit '*' 16 + 15`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 16 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 16 + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 16 + 2`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 16 + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 16 + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 16 + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 16 + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 16 + 7`
		mknod r${name}${unit}i	c $chr `expr $unit '*' 16 + 8`
		mknod r${name}${unit}j	c $chr `expr $unit '*' 16 + 9`
		mknod r${name}${unit}k	c $chr `expr $unit '*' 16 + 10`
		mknod r${name}${unit}l	c $chr `expr $unit '*' 16 + 11`
		mknod r${name}${unit}m	c $chr `expr $unit '*' 16 + 12`
		mknod r${name}${unit}n	c $chr `expr $unit '*' 16 + 13`
		mknod r${name}${unit}o	c $chr `expr $unit '*' 16 + 14`
		mknod r${name}${unit}p	c $chr `expr $unit '*' 16 + 15`
		chgrp operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

vnd*)
	umask 2 ; unit=`expr $i : 'vnd\(.*\)'`
	for name in vnd svnd; do
		blk=14; chr=19;
		case $name in
		vnd)	off=0;;
		svnd)	off=128;;
		esac
		rm -f $name$unit? r$name$unit?
		mknod ${name}${unit}a	b $blk `expr $unit '*' 16 + $off + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 16 + $off + 1`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 16 + $off + 2`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 16 + $off + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 16 + $off + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 16 + $off + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 16 + $off + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 16 + $off + 7`
		mknod ${name}${unit}i	b $blk `expr $unit '*' 16 + $off + 8`
		mknod ${name}${unit}j	b $blk `expr $unit '*' 16 + $off + 9`
		mknod ${name}${unit}k	b $blk `expr $unit '*' 16 + $off + 10`
		mknod ${name}${unit}l	b $blk `expr $unit '*' 16 + $off + 11`
		mknod ${name}${unit}m	b $blk `expr $unit '*' 16 + $off + 12`
		mknod ${name}${unit}n	b $blk `expr $unit '*' 16 + $off + 13`
		mknod ${name}${unit}o	b $blk `expr $unit '*' 16 + $off + 14`
		mknod ${name}${unit}p	b $blk `expr $unit '*' 16 + $off + 15`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 16 + $off + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 16 + $off + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 16 + $off + 2`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 16 + $off + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 16 + $off + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 16 + $off + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 16 + $off + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 16 + $off + 7`
		mknod r${name}${unit}i	c $chr `expr $unit '*' 16 + $off + 8`
		mknod r${name}${unit}j	c $chr `expr $unit '*' 16 + $off + 9`
		mknod r${name}${unit}k	c $chr `expr $unit '*' 16 + $off + 10`
		mknod r${name}${unit}l	c $chr `expr $unit '*' 16 + $off + 11`
		mknod r${name}${unit}m	c $chr `expr $unit '*' 16 + $off + 12`
		mknod r${name}${unit}n	c $chr `expr $unit '*' 16 + $off + 13`
		mknod r${name}${unit}o	c $chr `expr $unit '*' 16 + $off + 14`
		mknod r${name}${unit}p	c $chr `expr $unit '*' 16 + $off + 15`
		chown root.operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
	done
	umask 77
	;;

tty0*)
	unit=`expr $i : 'tty0\(.*\)'`
	rm -f ser${unit} tty${unit} tty0${unit}
	case ${unit} in
	0|1)
		mknod tty0${unit} c 7 ${unit}
		chown uucp.wheel tty0${unit}
		;;
	*)
		echo bad unit for serial tty in: $i
		;;
	esac
	;;

ttye*)
	unit=`expr $i : 'ttye\(.*\)'`
	rm -f ttye${unit}
	rm -f ite*
	case $unit in
	0|1)
		mknod ttye${unit} c 11 ${unit}
		;;
	*)
		echo bad unit for ttye in: $i
		;;
	esac
	;;

pty*)
	class=`expr $i : 'pty\(.*\)'`
	case $class in
	0) offset=0 name=p;;
	1) offset=16 name=q;;
	2) offset=32 name=r;;
	3) offset=48 name=s;;
# Note that telnetd, rlogind, and xterm (at least) only look at p-s.
	4) offset=64 name=t;;
	*) echo bad unit for pty in: $i;;
	esac
	case $class in
	0|1|2|3|4)
		umask 0
		n=0
		while [ $n -lt 16 ]
		do
			nam=$name`hex $n`
			rm -f {tty,pty}$nam
			mknod tty$nam c 4 "$(( $offset + $n ))"
			mknod pty$nam c 5 "$(( $offset + $n ))"
			n="$(( $n + 1 ))"
		done
		umask 77
		;;
	esac
	;;

st*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	st*) name=st;  chr=20; blk=5;;
	esac
	rm -f $name$unit n$name$unit e$name$unit en$name$unit \
		r$name$unit nr$name$unit er$name$unit enr$name$unit 
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}	b $blk `expr $unit '*' 16 + 0`
		mknod n${name}${unit}	b $blk `expr $unit '*' 16 + 1`
		mknod e${name}${unit}	b $blk `expr $unit '*' 16 + 2`
		mknod en${name}${unit}	b $blk `expr $unit '*' 16 + 3`
		mknod r${name}${unit}	c $chr `expr $unit '*' 16 + 0`
		mknod nr${name}${unit}	c $chr `expr $unit '*' 16 + 1`
		mknod er${name}${unit}	c $chr `expr $unit '*' 16 + 2`
		mknod enr${name}${unit}	c $chr `expr $unit '*' 16 + 3`
		chgrp operator ${name}${unit} n${name}${unit} \
			e$name$unit en$name$unit \
			r${name}${unit} nr${name}${unit} \
			er${name}${unit} enr${name}${unit} 
		chmod 640 ${name}${unit} n${name}${unit} \
			e$name$unit en$name$unit \
			r${name}${unit} nr${name}${unit} \
			er${name}${unit} enr${name}${unit} 
		;;
	*)
		echo bad unit for tape in: $i
		;;
	esac
	umask 77
	;;

ch*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	ch*) name=ch;  chr=10;;
	esac
	rm -f $name$unit
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}	c $chr `expr $unit '*' 16 + 0`
		chgrp operator ${name}${unit}
		chmod 640 ${name}${unit}
		;;
	*)
		echo bad unit for media changer in: $i
		;;
	esac
	umask 77
	;;

cd*)
	umask 2 ; unit=`expr $i : '..\(.*\)'`
	case $i in
	cd*) name=cd; blk=3; chr=9;;
	esac
	rm -f $name$unit? r$name$unit?
	case $unit in
	0|1|2|3|4|5|6)
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 8 + 3`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 8 + 3`
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

bpf*)
	unit=`expr $i : 'bpf\(.*\)'`
	rm -f bpf${unit}
	mknod bpf${unit} c 22 ${unit}
	chown root.wheel bpf${unit}
	;;

tun*)
	unit=`expr $i : 'tun\(.*\)'`
	rm -f tun$unit
	mknod tun$unit c 23 $unit
	chmod 600 tun$unit
	chown root.wheel tun$unit
	;;

rd*)
	blk=17; chr=17;
	umask 2 ; unit=`expr $i : '.*d\(.*\)'`
	rm -f rd${unit}a rd${unit}c rrd${unit}a rrd${unit}c
	mknod rd${unit}a b ${blk} `expr $unit '*' 16 + 0`
	mknod rd${unit}c b ${blk} `expr $unit '*' 16 + 2`
	mknod rrd${unit}a c ${chr} `expr $unit '*' 16 + 0`
	mknod rrd${unit}c c ${chr} `expr $unit '*' 16 + 2`
	chown root.operator rd${unit}[ac] rrd${unit}[ac]
	chmod 640 rd${unit}[ac] rrd${unit}[ac]
	umask 77
	;;

lkm)
	rm -f lkm
	mknod lkm c 24 0
	chown root.kmem lkm
	chmod 640 lkm
	;;

local)
	umask 0
	test -s MAKEDEV.local && sh MAKEDEV.local
	;;

*)
	echo $i: unknown device
esac
done
