#!/usr/bin/perl
#
# $OpenBSD: mdoclint,v 1.11 2008/11/23 17:07:36 jmc Exp $
# $NetBSD: mdoclint,v 1.18 2008/01/05 09:03:50 wiz Exp $
#
# Copyright (c) 2001-2008 Thomas Klausner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR, THOMAS KLAUSNER,
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

use strict;
use warnings;

$| = 1;

package Parser;
use Getopt::Std;

use vars qw(
	$opt_a $opt_D $opt_d $opt_e $opt_F $opt_f $opt_H $opt_h $opt_m
	$opt_n $opt_o $opt_P $opt_p $opt_r $opt_S $opt_s $opt_v
	$opt_X $opt_x
);


my $arch=`uname -m`;
chomp($arch);
my $options="aDdeFfHhmnoPprSsvXx";

sub usage {
	print STDERR <<"EOF";
mdoclint: verify man page correctness
usage:	mdoclint [-$options] file ...
	-a	warn about SEE ALSO section problems
	-D	warn about bad casing and archs in .Dt
	-d	warn about bad date strings (in .Dd only)
	-e	warn about unsorted errors (for functions)
	-F	fix whitespace problems (asks before overwriting)
	-f	warn about possible incorrect .Fn syntax
	-H	warn about characters that produce problems in HTML output
	-h	display this help text
	-m	warn about man pages that are not in mdoc(7) format
	-n	warn about .Nd's ending in '.'
	-o	warn about non-empty .Os strings
	-P	warn about paragraph problems
	-p	warn about punctuation problems
	-r	warn about missing RCS Id
	-S	warn about any .Sh weirdness
	-s	warn about whitespace problems
	-v	verbose output
	-X	warn about explicit mentions of FreeBSD, NetBSD, or OpenBSD
	-x	warn about cross-references with missing targets
Default is -aDdfHmnoPprSsXx if no flag is specified.
EOF
	exit(0);
}


my %short = (
    "Free" => ".Fx",
    "Net" => ".Nx",
    "Open" => ".Ox"
);

my %sections = (
		"NAME" => 1,
		"SYNOPSIS" => 2,
		"DESCRIPTION" => 3,
		"RETURN VALUES" => 4,
		"ENVIRONMENT" => 5,
		"FILES" => 6,
		"EXAMPLES" => 7,
		"DIAGNOSTICS" => 8,
		"ERRORS" => 9,
		"SEE ALSO" => 10,
		"STANDARDS" => 11,
		"HISTORY" => 12,
		"AUTHORS" => 13,
		"CAVEATS" => 14,
		"BUGS" => 15
);

sub debug 
{
	my $self = shift;
    	print STDOUT "debug: $self->{fn}:$self->{ln}: @_\n" if $opt_v;
}

sub warning 
{
	my $self = shift;
	print STDOUT "$self->{fn}:$self->{ln}: @_\n";
}

sub handle_options 
{
	getopts($options);
	$opt_h and usage();

	# default to all warnings if no flag is set
	unless ($opt_a or $opt_D or $opt_d or $opt_e or $opt_f or $opt_H 
	    or $opt_m or $opt_n or $opt_o or $opt_P or $opt_p or $opt_r 
	    or $opt_S or $opt_s or $opt_X or $opt_x) {
		$opt_a = $opt_D = $opt_d = $opt_f = $opt_H = $opt_m = 
		    $opt_n = $opt_o = $opt_P = $opt_p = $opt_r = $opt_S = 
		    $opt_s = $opt_X = $opt_x = 1;
	}
}


sub verify_xref 
{
	my ($self, $page, $section, $pre, $post) = @_;
	if ("$page.$section" eq $self->{fn}) {
		$self->warning("Xref to itself (use .Nm instead)");
	}
	# try to find corresponding man page
	for my $dir ("/usr/share/man", "/usr/X11R6/man") {
		for my $a ("", $arch) {
			for my $page ("cat$section/$a/$page.0", 
			    "man$section/$a/$page.$section") {
				return 1 if -f "$dir/$page";
			}
		}
	}
	return 1 if -f "./$page.$section";

	$self->warning($pre."trailing Xref to $page($section)$post");
	return 0;
}

sub new
{
	my ($class, $fn) = @_;

	my $o = {
		mandoc_p => 1,
		all => '',
		lastline => '',
		changes => 0,
		rcsidseen => 0,
		lastsh => 0,
		sasection => 0,
		saname => '',
		sarest => ',',
		insa => 0,
		inliteral => 0,
		shseen => {},
		last_error_name => '',
		current_section => '',
		fn => $fn
	};
	open my $input, '<', $fn or die "can't open input file $fn";
	$o->{file} = $input;
	$o->{ln} = 0;
	bless $o, $class;
}

sub next_line
{
	my ($self) = @_;

	my $l = readline($self->{file});
	if (defined $l) {
		$self->{ln}++;
	}
	return $l;
}

sub close
{
	my ($self) = @_;

	close($self->{file});
}

sub process_line
{
	my ($s, $_) = @_;
	chomp;
	if (/\$OpenBSD\b.*\$/o) {
	    $s->{rcsidseen} = 1;
	}
	if (/^\.TH\s+/o) {
	    $s->warning("not mandoc") if $opt_m;
	    $s->{mandoc_p} = 0;
#	    /^.TH\s*[\w-_".]+\s*([1-9])/;
#	    $section = $1;
	}
#	if (/^.Dt\s*[\w-_".]+\s*([1-9])/) {
#	    $section = $1;
#	}
	if ($opt_D and /^\.Dt\s+/o) {
	    if (! /^\.Dt\s+(?:[A-Z\d._-]+)\s+[1-9](?:\s+(?:alpha|amd64|arm|armish|aviion|cats|hp300|hppa|hppa64|i386|landisk|luna88k|mac68k|macppc|mvme68k|mvme88k|sgi|socppc|sparc|sparc64|vax|zaurus))?$/o)  {
		$s->warning("bad .Dt: `$_'");
	    }
	}

	if ($opt_a) {
	    if ($s->{insa} == 0) {
		if (/^\.Sh\s+SEE ALSO$/o) {
		    $s->{insa} = 1;
		}
	    } elsif ($s->{insa} == 1) {
		if (/^\.Sh\s+/o) {
		    if (not $s->{sarest} eq "") {
			$s->warning("unneeded characters at end of SEE ALSO:".
				"`$s->{sarest}'");
			# to avoid a second warning at EOF
			$s->{sarest} = "";
		    }
		    # finished SEE ALSO section
		    $s->{insa} = 2;
		}
		if (/^\.Xr\s+(\S+)\s+(3p|[1-9])\s?(.*)?$/o) {
		    my ($saname, $sasection, $sarest) = ($1, $2, $3);
		    $saname =~ s/^\\&//o;
		    if ($s->{sasection} gt $sasection
			or ($s->{sasection} eq $sasection and
			    ($s->{saname} cmp $saname) > 0)) {
			$s->warning("SEE ALSO: `.Xr $s->{saname} $s->{sasection}' should "
				. "be after `.Xr $saname $sasection'");
		    }
		    if ($s->{sarest} ne ",") {
			$s->warning("SEE ALSO: .Xr not separated by ".
				"comma, but `$s->{sarest}'");
		    }
		    $s->{saname} = $saname;
		    $s->{sasection} = $sasection;
		    $s->{sarest} = $sarest;
		}
		if (/^\.Rs(?:\s+|$)/o) {
		    if ($s->{sarest} ne "") {
			$s->warning("SEE ALSO: Not necessary to separate".
				" .Xr from .Rs by `$s->{sarest}'");
		    }
		    $s->{sarest} = "";
		}
	    }
	}

	if ($opt_f and /^\.Fn.*,.+/o) {
	    $s->warning("possible .Fn misuse: `$_'");
	}
	if ($opt_H and not /^\.\\\"/o and (/^(?:[<>])/o or /[^\\][<>]/o)) {
	    $s->warning("use \*(Lt \*(Gt (or .Aq) instead of < >: `$_'");
	}
	if ($opt_S) {
	    if (/^\.Sh\s+(.*)\s*$/o) {
		if (not $sections{$1}) {
		    $s->warning("unknown section header: `$1'");
		} else {
		    if ($s->{lastsh} >= $sections{$1}) {
			$s->warning("section header `$1' in wrong order");
		    }
		    $s->{shseen}->{$1} = 1;
		    $s->{lastsh} = $sections{$1};
		}
	    }
	}

	if ($opt_s) {
	    if (/\s+$/o) {
		$s->warning("trailing space: `$_'");
		if ($opt_F) {
		    s/\s+$//o;
		    $s->{changes} = 1;
		}
	    }
# this check only bought us something for phantasia.6
#	    # we don't want to match at BOF
#	    if (/.\.\t/) {
#		$s->warning("tab after dot (`.') -- probably malformatting: $_");
#	    }
	}
	if ($opt_X) {
	    if (not /^\.\\\"/o and /\b(Free|Net|Open)BSD\b/o
		and not /\b(?:www|ftp)\.(?:Free|Net|Open)BSD\.org\b/o
		and not /\bOpenBSD\::.*3p\b/o
		and not /\/pub\/OpenBSD\//o
		and not /\@(?:Free|Net|Open)BSD\.(?i:org)\b/o) {
		$s->warning("verbose mention of `$1BSD' instead of "
			. "`$short{$1}': `$_'");
	    }
	    if (/^\./o and (/Bx (Open)/o or /Bx (Free)/o or /Bx (Net)/o)) {
		$s->warning("`.Bx $1' found -- use $short{$1} instead");
	    }
	}
	if ($opt_o) {
	    if (/^\.Os/o && !/^\.Os\s*$/o) {
		/^\.Os(.*)/o;
		$s->warning(".Os used with argument `$1'");
	    }
	}

	if ($opt_n) {
	    if (/^\.Nd/o and /\.\s*$/o) {
		$s->warning(".Nd ends with a dot: `$_'");
	    }
	}
	if ($opt_p) {
	    if (not /^\.\\\"/o and /\w\w\.\s+[A-Z]/o) {
		$s->warning("new sentence, new line: `$_'");
	    }
	    if (not /^\.\\\"/o and /^\... .*[^\s][\.();,\[\]\{\}:]$/o
		and not /\s\.\.\.$/o and not /\\&.$/o) {
		$s->warning("punctuation in format string without space: `$_'");
	    }
	    if (not /^\.\\\"/o and /^\./o and /Ns [\.();,\[\]\{\}:]/o) {
		$s->warning("possible Ns abuse: `$_'");
	    }
	    if (/(\w+)\(\)/o) {
		$s->warning("use .Fn or .Xr for functions: `$1()'");
	    }
	}
	if ($opt_x) {
	    if ($s->{mandoc_p}) {
		my $destruct = $_;
		$destruct =~ s/\\\&([\w\.])/$1/o;
		if ($destruct =~ /^\.Xr\s+([\w\:\.\-\+\/]+)\s+(3p|[0-9])(.*)/o) {
		    $s->debug("Xref to $1($2) found: `$_'");
		    $s->verify_xref($1, $2, "", "");
		    if ($3 =~ /^\S/o) {
			$s->warning("No space after section number in Xref: `$_'");
		    }
		} elsif ($destruct =~ /^\.Xr/o) {
		    $s->warning("Weird Xref found: `$_'");
		}
	    } else {
		my $destruct = $_;
		$destruct =~ s/\\f.//go;
		if ($destruct !~ /^\.\\\"/o) {
		    while ($destruct =~ s/([-\w.]+)\s*\((3p|[0-9])\)//o) {
			$s->debug("possible Xref to $1($2) found: `$_'");
			$s->verify_xref($1, $2, "possible ", ": `$_'");
			# so that we have a chance to find more than one
			# per line
			$destruct =~ s/(\w+)\s*\((3p|[0-9])\)//o;
		    }
		}
	    }
	}
	if ($opt_d) {
	    if (/^\.Dd/o and not /^\.Dd [\$]Mdocdate\b/o) {
		$s->warning("Invalid date found: `$_'");
	    }
	}

	if ($opt_P) {
	    if (/^\.Bd\b.*-literal/o) {
		$s->{inliteral} = 1;
	    }
	    if ($s->{inliteral} == 1) {
		if (/^\.Ed\b/o) {
		    $s->{inliteral} = 0;
		}
	    } elsif (/^$/o) {
		$s->warning("Paragraph problem: empty line -- use .Pp for".
			" paragraphs");
	    }
	    if ($s->{lastline} =~ /^\.Pp/o and (/^(\.S[sh])/o or /^(\.Pp)/o)) {
		$s->warning("Paragraph problem: $1 after .Pp");
	    }
	    if (/^\.Pp/o and $s->{lastline} =~ /^(\.S[sh])/o) {
		$s->warning("Paragraph problem: .Pp after $1");
	    }
	}

	# Check whether the list of possible errors for a function is
	# sorted alphabetically.
	#
	if ($opt_e) {
		/^\.Sh\s+(.*)$/o and $s->{current_section} = $1;

		# Error names should not be sorted across different lists.
		# (see bind(2) for an example.)
		#
		/^\.Bl\s+/o and $s->{last_error_name} = "";

		if ($s->{current_section} eq "ERRORS" and
		    /^\.It\s+Bq\s+Er\s+(E[\w_]+)$/o) {
			my $current_error_name = $1;

			if ($s->{last_error_name} eq $current_error_name) {
				$s->warning("Duplicate item for "
					. "$current_error_name.");
			} elsif ($current_error_name lt $s->{last_error_name}) {
				$s->warning("$s->{last_error_name} and "
					. "$current_error_name are not in "
					. "alphabetical order.");
			}
			$s->{last_error_name} = $current_error_name;
		}
	}

	$s->{lastline} = $_;
	$s->{all} .= "$_\n";
}

sub finish
{
	my ($s) = @_;

	if ($opt_r and not $s->{rcsidseen}) {
	    $s->warning("Missing RCS Id");
	}

	if ($opt_P and $s->{lastline} =~ /^\.Pp/o) {
	    $s->warning("Paragraph problem: .Pp at EOF");
	}

	if ($opt_a and $s->{insa} > 0 and not $s->{sarest} eq "") {
	    $s->warning("unneeded characters at end of SEE ALSO: `$s->{sarest}'");
	}

#    	if (not ($fn =~ /$section$/)) {
#		$s->warning("section doesn't match (internal value: $section)");
#    	}
	if ($s->{mandoc_p} and $opt_S) {
	    foreach my $i (qw (NAME SYNOPSIS DESCRIPTION)) {
		if (not ($s->{shseen}{$i})) {
		    $s->warning("missing $i section");
		}
	    }
	}
}

package main;

sub handle_file 
{
	my $parser = Parser->new($_[0]);

	while (my $_ = $parser->next_line) {
		$parser->process_line($_);
	}

	$parser->finish;
	$parser->close;
	if ($Parser::opt_F and $parser->{changes}) {
		open OUT, ">$_[0].new" or 
		    die "can't open output file `$_[0].new'";
		print OUT $parser->{all};
		close OUT;
		system("mv -i $_[0].new $_[0]");
	}
}

Parser->handle_options;
foreach my $file (@ARGV) {
    handle_file($file);
}
