*vim_help.txt*	For Vim version 4.4.  Last modification: 1996 Aug 3

			VIM help file

VIM stands for Vi IMproved.  Most of VIM was made by Bram Moolenaar.
									   k
      Move around:  Use the cursor keys, or "h" to go left,		 h   l
		    "j" to go down, "k" to go up, "l" to go right.	   j
Close this window:  Use ":q".
Jump to a subject:  Position the cursor on the tag between |bars| and hit
		    CTRL-].  Use CTRL-T to go back.
   With the mouse:  ":set mouse=a" to enable the mouse (in xterm).
		    Hit "g" and click left mouse button on tag between |bars|.
		    Hit "g" and click right mouse button to go back.
Getting help on a
 specific subject:  It is possible to go directly to whatever you want help
		    on, by giving an argument to the ":help" command, |:help|.
		    It is possible to further specify the context:
			  what			prepend    example
		      Normal mode commands     (nothing)   :help x
		      Visual mode commands	  v_	   :help v_u
		      Insert mode commands	  i_	   :help i_<Esc>
		      command-line commands	  :	   :help :quit
		      command-line editing	  c_	   :help c_<Del>
		      Vim command options	  -	   :help -r
		      options			  '	   :help 'textwidth'

 tag	  subject			 tag	  subject	*index*

|X_lr|	 motion: Left-right		|X_re|	 Repeating commands
|X_ud|	 motion: Up-down		|X_km|	 Key mapping
|X_tm|	 motion: Text object		|X_ab|	 Abbreviations
|X_pa|	 motion: Pattern searches	|X_op|	 Options
|X_ma|	 motion: Marks			|X_ur|	 Undo/Redo commands
|X_vm|	 motion: Various		|X_et|	 External commands
|X_ta|	 motion: Using tags		|X_qf|	 Quickfix commands
|X_sc|	 Scrolling			|X_vc|	 Various commands
|X_in|	 insert: Inserting text		|X_ce|	 Ex: Command-line editing
|X_ai|	 insert: Keys			|X_ra|	 Ex: Ranges
|X_ss|	 insert: Special keys		|X_ex|	 Ex: Special characters
|X_di|	 insert: Digraphs		|X_ed|	 Editing a file
|X_si|	 insert: Special inserts	|X_fl|	 Using the argument list
|X_de|	 change: Deleting text		|X_wq|	 Writing and quitting
|X_cm|	 change: Copying and moving	|X_st|	 Starting VIM
|X_ch|	 change: Changing text		|X_ac|	 Automatic commands
|X_co|	 change: Complex		|X_wi|	 Multi-window functions
|X_vi|	 Visual mode			|X_bu|	 Buffer list functions
|X_to|	 Text objects

|howto|		how to do common things
|copying|	About copying Vim and Uganda
|credits|	People who contributed
|www|		Vim on the World Wide Web
|bugs|		Where to send bug reports

list of documentation files:		      remarks about specific systems:

|vim_help.txt|	quick reference (this file)	    |vim_ami.txt|   Amiga
|vim_idx.txt|	alphabetical index		    |vim_arch.txt|  Archimedes
|vim_ref.txt|	reference manual		    |vim_dos.txt|   MS-DOS
|vim_win.txt|	reference for window commands	    |vim_mac.txt|   Macintosh
|vim_diff.txt|	differences between Vim and Vi	    |vim_mint.txt|  MiNT
|vim_digr.txt|	list of available digraphs	    |vim_os2.txt|   OS/2
|vim_tips.txt|	tips on using Vim		    |vim_unix.txt|  Unix
|vim_gui.txt|	about the Graphical User Interface  |vim_w32.txt|   Win-NT/95
|vim_rlh.txt|	about right-to-left editing
|vim_40.txt|	about this version
|vim_tags|	all the tags you can jump to (index of tags)

------------------------------------------------------------------------------
How to ...				*howdoi* *how_do_i* *howto* *how_to*

exit? I'm trapped, help me!			|:quit|
initialize Vim					|initialization|
suspend Vim					|suspend|
recover after a crash				|crash_recovery|
keep a backup of my file			|backup|

edit files					|edit_files|
insert text					|inserting|
delete text					|deleting|
change text					|changing|
edit binary files				|edit_binary|
copy and move text				|copy_move|
repeat commands					|repeating|
undo and redo					|undo_redo|
format text					|formatting|
format comments					|format_comments|
indent C programs				|C_indenting|
automatically set indent			|'autoindent'|

move around					|cursor_motions|
word motions					|word_motions|
left-right motions				|left_right_motions|
up-down motions					|up_down_motions|
text-object motions				|object_motions|
various motions					|various_motions|
text-object selection				|object_select|
move freely beyond beginning/end of line	|'whichwrap'|
specify pattern for searches			|pattern_searches|
do tags and special searches			|tags_and_searches|
search in include'd files used to find
	variables, functions, or macros		|include_search|
look up manual for the keyword under cursor	|K|

scroll						|scrolling|
scroll horizontally/sideways			|'sidescroll'|
set scroll boundary				|'scrolloff'|

change modes					|mode_switching|
use visual mode					|Visual_mode|
start Vim in Insert mode			|'insertmode'|

map keys					|key_mapping|
create abbreviations				|abbreviations|

expand a tab to spaces in Insert mode		|ins_expandtab|
insert contents of a register in Insert mode	|i_CTRL-R|
complete words in Insert mode			|ins_completion|
break a line before it gets too long		|ins_textwidth|

do command-line editing				|cmdline_editing|
do command-line completion			|cmdline_completion|
increase the height of command-line		|'cmdheight'|
specify command-line ranges			|cmdline_ranges|
specify commands to be executed automatically
    before/after reading/writing
    entering/leaving a buffer/window		|autocommand|

write automatically				|'autowrite'|
speedup edit-compile-edit cycle	or compile
	and fix errors within Vim		|quickfix|

set options					|options|
set options automatically			|auto_setting|
save settings					|save_settings|
comment my exrc/vimrc/gvimrc files		|:quote|
change the default help height			|'helpheight'|
set various highlighting modes			|'highlight'|
set the window title				|'title'|
set window icon title				|'icon'|
avoid seeing the change messages on every line	|'report'|
avoid "Hit RETURN ..." messages			|'shortmess'|

use mouse with Vim				|mouse_using|
manage multiple windows and buffers		|vim_win.txt|
use the gui					|vim_gui.txt|
catch 40 (or more!) winks, or take a catnap!	|:sleep|
do dishes using Vim				You can't!  (yet)

------------------------------------------------------------------------------
N is used to indicate an optional count that can be given before the command.
------------------------------------------------------------------------------
*X_lr*		Left-right motions

|h|	N  h		left (also: CTRL-H, <BS>, or <Left> key)
|l|	N  l		right (also: <Space> or <Right> key)
|0|	   0		to first character in the line (also: <Home> key)
|^|	   ^		to first non-blank character in the line
|$|	N  $		to the last character in the line (N-1 lines lower)
			   (also: <End> key)
|g0|	N  g0		to first character in screen line (differs from "0"
			   when lines wrap)
|g^|	N  g^		to first non-blank character in screen line (differs
			   from "^" when lines wrap)
|g$|	N  g$		to last character in screen line (differs from "$"
			   when lines wrap)
|bar|	N  |		to column N (default: 1)
|f|	N  f<char>	to the Nth occurrence of <char> to the right
|F|	N  F<char>	to the Nth occurrence of <char> to the left
|t|	N  t<char>	till before the Nth occurrence of <char> to the right
|T|	N  T<char>	till before the Nth occurrence of <char> to the left
|;|	N  ;		repeat the last "f", "F", "t", or "T" N times
|,|	N  ,		repeat the last "f", "F", "t", or "T" N times in
			   opposite direction
------------------------------------------------------------------------------
*X_ud*		Up-down motions

|k|	N  k		up N lines (also: CTRL-P and <Up>)
|j|	N  j		down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
|-|	N  -		up N lines, on the first non-blank character
|+|	N  +		down N lines, on the first non-blank character (also:
			   CTRL-M and <CR>)
|_|	N  _		down N-1 lines, on the first non-blank character
|G|	N  G		goto line N (default: last line), on the first
			   non-blank character
|gg|	N  gg		goto line N (default: first line), on the first
			   non-blank character
|N%|	N  %		goto line N percentage down in the file.  N must be
			   given, otherwise it is the |%| command.
|gk|	N  gk		up N screen lines (differs from "k" when line wraps)
|gj|	N  gj		down N screen lines (differs from "j" when line wraps)
------------------------------------------------------------------------------
*X_tm*		Text object motions

|w|	N  w		N words forward
|W|	N  W		N blank-separated WORDS forward
|e|	N  e		forward to the end of the Nth word
|E|	N  E		forward to the end of the Nth blank-separated WORD
|b|	N  b		N words backward
|B|	N  B		N blank-separated WORDS backward
|ge|	N  ge		backward to the end of the Nth word
|gE|	N  gE		backward to the end of the Nth blank-separated WORD

|)|	N  )		N sentences forward
|(|	N  (		N sentences backward
|}|	N  }		N paragraphs forward
|{|	N  {		N paragraphs backward
|]]|	N  ]]		N sections forward, at start of section
|[[|	N  [[		N sections backward, at start of section
|][|	N  ][		N sections forward, at end of section
|[]|	N  []		N sections backward, at end of section
|[(|	N  [(		N times back to unclosed '('
|[(|	N  [{		N times back to unclosed '{'
|])|	N  ])		N times forward to unclosed ')'
|])|	N  ]}		N times forward to unclosed '}'
|[#|	N  [#		N times back to unclosed "#if" or "#else"
|]#|	N  ]#		N times forward to unclosed "#else" or "#endif"
|[star|	N  [*		N times back to start of comment "/*"
|]star|	N  ]*		N times forward to end of comment "*/"
------------------------------------------------------------------------------
*X_pa*		Pattern searches

|/|	N  /{pattern}[/[offset]]<CR>
			search forward for the Nth occurrence of {pattern}
|?|	N  ?{pattern}[?[offset]]<CR>
			search backward for the Nth occurrence of {pattern}
|/<CR>|	N  /<CR>	repeat last search, in the forward direction
|?<CR>|	N  ?<CR>	repeat last search, in the backward direction
|n|	N  n		repeat last search
|N|	N  N		repeat last search, in opposite direction
|star|	N  *		search forward for the identifier under the cursor
|#|	N  #		search backward for the identifier under the cursor
|gstar|	N  g*		like "*", but also find partial matches
|g#|	N  g#		like "#", but also find partial matches
|gd|	   gd		goto local declaration of identifier under the cursor
|gD|	   gD		goto global declaration of identifier under the cursor

|search_pattern|	Special characters in search patterns

			meaning		   magic       nomagic
	   matches any single character      .		  \.
		  matches start of line      ^		  ^
		    matches end of line      $		  $
		  matches start of word      \<		  \<
		    matches end of word      \>		  \>
   matches a single char from the range      [a-z]	  \[a-z]
 matches a single char not in the range      [^a-z]	  \[^a-z]
	     matches an identifier char      \i		  \i
	      idem but excluding digits      \I		  \I
	    matches a keyword character      \k		  \k
	      idem but excluding digits      \K		  \K
	   matches a filename character      \f		  \f
	      idem but excluding digits      \F		  \F
	  matches a printable character      \p		  \p
	      idem but excluding digits      \P		  \P

			  matches <Esc>	     \e		  \e
			  matches <Tab>      \t		  \t
			   matches <CR>	     \r		  \r
			   matches <BS>	     \b		  \b

matches 0 or more of the preceding atom      *		  \*
matches 1 or more of the preceding atom      \+		  \+
   matches 0 or 1 of the preceding atom      \=		  \=
		 separates two branches      \|		  \|
	   group a pattern into an atom      \(\)	  \(\)

|search_offset|		Offsets allowed after search command

    [num]	[num] lines downwards, in column 1
    +[num]	[num] lines downwards, in column 1
    -[num]	[num] lines upwards, in column 1
    e[+num]	[num] characters to the right of the end of the match
    e[-num]	[num] characters to the left of the end of the match
    s[+num]	[num] characters to the right of the start of the match
    s[-num]	[num] characters to the left of the start of the match
    b[+num]	[num] characters to the right of the start (begin) of the match
    b[-num]	[num] characters to the left of the start (begin) of the match
    ;{search command}	execute {search command} next
------------------------------------------------------------------------------
*X_ma*		Marks and motions

|m|	   m<a-zA-Z>	mark current position with mark <a-zA-Z>
|`a|	   `<a-z>	go to mark <a-z> within current file
|`A|	   `<A-Z>	go to mark <A-Z> in any file
|`0|	   `<0-9>	go to the position where Vim was last exited
|``|	   ``		go to the position before the last jump
|`"|	   `"		go to the position when last editing this file
|`[|	   `[		go to the start of the previously operated or put text
|`]|	   `]		go to the end of the previously operated or put text
|`<|	   `<		go to the start of the (previous) Visual area
|`>|	   `>		go to the end of the (previous) Visual area
|'|	   '<a-zA-Z0-9[]'"<>>
			same as `, but on the first non-blank in the line
|:marks|  :marks	print the active marks
|CTRL-O|  N  CTRL-O	go to Nth older position in jump list
|CTRL-I|  N  CTRL-I	go to Nth newer position in jump list
|:ju|	  :ju[mps]	print the jump list
------------------------------------------------------------------------------
*X_vm*		Various motions

|%|	   %		find the next brace, bracket, comment, or "#if"/
			   "#else"/"#endif" in this line and go to its match
|H|	N  H		go to the Nth line in the window, on the first
			   non-blank
|M|	   M		go to the middle line in the window, on the first
			   non-blank
|L|	N  L		go to the Nth line from the bottom, on the first
			   non-blank
------------------------------------------------------------------------------
*X_ta*		Using tags

|:ta|	   :ta[g][!] {tag}	Jump to tag {tag}
|:ta|	   :[count]ta[g][!]	Jump to [count]'th newer tag in tag list
|CTRL-]|      CTRL-]		Jump to the tag under cursor, unless changes
				   have been made
|CTRL-T|   N  CTRL-T		Jump back from Nth older tag in tag list
|:po|	   :[count]po[p][!]	Jump back from [count]'th older tag in tag list
|:tags|	   :tags		Print tag list
------------------------------------------------------------------------------
*X_sc*		Scrolling

|CTRL-E|	N  CTRL-E	window N lines downwards (default: 1)
|CTRL-D|	N  CTRL-D	window N lines Downwards (default: 1/2 window)
|CTRL-F|	N  CTRL-F	window N pages Forwards (downwards)
|CTRL-Y|	N  CTRL-Y	window N lines upwards (default: 1)
|CTRL-U|	N  CTRL-U	window N lines Upwards (default: 1/2 window)
|CTRL-B|	N  CTRL-B	window N pages Backwards (upwards)
|z<CR>|		   z<CR> or zt	redraw, current line at top of window
|z.|		   z.	 or zz	redraw, current line at center of window
|z-|		   z-	 or zb	redraw, current line at bottom of window

|zh|		N  zh		scroll screen N characters to the right
|zl|		N  zl		scroll screen N characters to the left
------------------------------------------------------------------------------
*X_in*		Inserting text

|a|	N  a	append text after the cursor (N times)
|A|	N  A	append text at the end of the line (N times)
|i|	N  i	insert text before the cursor (N times) (also: <Insert>)
|I|	N  I	insert text before the first non-blank in the line (N times)
|gI|	N  gI	insert text in column 1 (N times)
|o|	N  o	open a new line below the current line, append text (N times)
|O|	N  O	open a new line above the current line, append text (N times)
------------------------------------------------------------------------------
*X_ai*		Keys in Insert mode

		 char			action in Insert mode
|i_<Esc>|	<Esc>		  end Insert mode, back to Normal mode
|i_CTRL-C|	CTRL-C		  like <Esc>, but do not do an abbreviation
|i_CTRL-A|	CTRL-A		  insert previously inserted text
|i_CTRL-@|	CTRL-@		  insert previously inserted text and stop
				     insert
|i_CTRL-R|	CTRL-R <0-9a-z%:.-"> insert contents of register <0-9a-z%:.-">
|i_<NL>|	<NL> or <CR> or CTRL-M or CTRL-J
				  begin new line
|i_CTRL-E|	CTRL-E		  insert the character from below the cursor
|i_CTRL-Y|	CTRL-Y		  insert the character from above the cursor
|i_CTRL-V|	CTRL-V <char>..	  insert character literally, or enter decimal
				     byte value
|i_CTRL-N|	CTRL-N		  insert next match of identifier before the
				     cursor
|i_CTRL-P|	CTRL-P		  insert previous match of identifier before
				     the cursor
|i_CTRL-X|	CTRL-X ...	  complete the word before the cursor in
				     various ways
|i_<BS>|	<BS> or CTRL-H	  delete the character before the cursor
|i_<Del>|	<Del>		  delete the character under the cursor
|i_CTRL-W|	CTRL-W		  delete word before the cursor
|i_CTRL-U|	CTRL-U		  delete all entered characters in the current
				     line
|i_CTRL-T|	CTRL-T		  insert one shiftwidth of indent in front of
				       the current line
|i_CTRL-D|	CTRL-D		  delete one shiftwidth of indent in front of
				     the current line
|i_0_CTRL-D|	0 CTRL-D	  delete all indent in the current line
|i_^_CTRL-D|	^ CTRL-D	  delete all indent in the current line,
				     restore indent in next line
|i_CTRL-K|	CTRL-K {char1} {char2}
				  enter digraph (See |X_di|)
|i_digraph|	{char1} <BS> {char2}
				  enter digraph if 'digraph' option set
|i_CTRL-B|	CTRL-B		  toggle 'revins' (reverse insert) option
------------------------------------------------------------------------------
*X_ss*		Special keys in Insert mode

|i_<Up>|	cursor keys	  move cursor left/right/up/down
|i_<S-Left>|	shift-left/right  one word left/right
|i_<S-Up>|	shift-up/down	  one screenful backward/forward
|i_CTRL-O|	CTRL-O {command}  execute {command}
|i_<End>|	<End>		  cursor after last character in the line
|i_<Home>|	<Home>		  cursor to first character in the line
------------------------------------------------------------------------------
*X_di*		Digraphs

|:dig|	   :dig[raphs]		show current list of digraphs
|:dig|	   :dig[raphs] {char1}{char2} {number} ...
				add digraph(s) to the list
------------------------------------------------------------------------------
*X_si*		Special inserts

|:r|	   :r [file]	   insert the contents of [file] below the cursor
|:r!|	   :r! {command}   insert the standard output of {command} below the
			      cursor
------------------------------------------------------------------------------
*X_de*		Deleting text

|x|	N  x		delete N characters under and after the cursor
|<Del>| N  <Del>	delete N characters under and after the cursor
|X|	N  X		delete N characters before the cursor
|d|	N  d{motion}	delete the text that is moved over with {motion}
|v_d|	{visual}d	delete the highlighted text
|dd|	N  dd		delete N lines
|D|	N  D		delete to end-of-line (and N-1 more lines)
|J|	N  J		join N-1 lines (delete newlines)
|v_J|	{visual}J	join the highlighted lines
|:d|	:[range]d [x]	delete [range] lines [into register x]
------------------------------------------------------------------------------
*X_cm*		Copying and moving text

|quote|	  "<char>	use register <char> for the next delete, yank, or put
|:reg|	  :reg		show the contents of all registers
|:reg|	  :reg {arg}	show the contents of registers mentioned in {arg}
|y|	  N  y{motion}	yank the text moved over with {motion} into a register
|v_y|	     {visual}y	yank the highlighted text into a register
|yy|	  N  yy		yank N lines into a register
|Y|	  N  Y		yank N lines into a register
|p|	  N  p		put a register after the cursor position (N times)
|P|	  N  P		put a register before the cursor position (N times)
|]p|	  N  ]p		like p, but adjust indent to current line
|[p|	  N  [p		like P, but adjust indent to current line
------------------------------------------------------------------------------
*X_ch*		Changing text

|R|	  N  R		enter Replace mode (repeat the entered text N times)
|c|	  N  c{motion}	change the text that is moved over with {motion}
|v_c|	     {visual}c	change the highlighted text
|cc|	  N  cc		change N lines
|S|	  N  S		change N lines
|C|	  N  C		change to end-of-line (and N-1 more lines)
|s|	  N  s		change N characters
|r|	  N  r<char>	replace N characters with <char>

|~|	  N  ~		switch case for N characters and advance cursor
|v_~|	     {visual}~	switch case for highlighted text
|v_u|	     {visual}u	make highlighted text lowercase
|v_U|	     {visual}U	make highlighted text uppercase
|g~|	     g~{motion} switch case for the text that is moved over with
			   {motion}
|gu|	     gu{motion} make the text that is moved over with {motion}
			   lowercase
|gU|	     gU{motion} make the text that is moved over with {motion}
			   uppercase

|CTRL-A|  N  CTRL-A	add N to the number at or after the cursor
|CTRL-X|  N  CTRL-X	subtract N from the number at or after the cursor

|<|	  N  <{motion}	move the lines that are moved over with {motion} one
			   shiftwidth left
|<<|	  N  <<		move N lines one shiftwidth left
|>|	  N  >{motion}	move the lines that are moved over with {motion} one
			   shiftwidth right
|>>|	  N  >>		move N lines one shiftwidth right
|gq|	  N  gq{motion}	format the lines that are moved over with {motion} to
			   'textwidth' length
|:ce|	  :[range]ce[nter] [width]
			center the lines in [range]
|:le|	  :[range]le[ft] [indent]
			left-align the lines in [range] [with indent]
|:ri|	  :[range]ri[ght] [width]
			right-align the lines in [range]
------------------------------------------------------------------------------
*X_co*		Complex changes

|!|	   N  !{motion}{command}<CR>
			filter the lines that are moved over through {command}
|!!|	   N  !!{command}<CR>
			filter N lines through {command}
|v_!|	      {visual}!{command}<CR>
			filter the highlighted lines through {command}
|:range!|  :[range]! {command}<CR>
			filter [range] lines through {command}
|=|	   N  ={motion}
			filter the lines that are moved over through "indent"
|==|	   N  ==	filter N lines through "indent"
|v_=|	      {visual}=
			filter the highlighted lines through "indent"
|:s|	   :[range]s[ubstitute]/{pattern}/{string}/[g][c]
			substitute {pattern} by {string} in [range] lines;
			   with [g], replace all occurrences of {pattern};
			   with [c], confirm each replacement
|:s|	   :[range]s[ubstitute] [g][c]
			repeat previous ":s" with new range and options
|&|	      &		Repeat previous ":s" on current line without options
|:ret|	   :[range]ret[ab][!] [tabstop]
			set 'tabstop' to new value and adjust white space
			   accordingly
------------------------------------------------------------------------------
*X_vi*		Visual mode

|v|	   v		start highlighting characters  }  move cursor and use
|V|	   V		start highlighting linewise    }  operator to affect
|CTRL-V|   CTRL-V	start highlighting blockwise   }  highlighted text
|v_o|	   o		exchange cursor position with start of highlighting
|gv|	   gv		start highlighting on previous visual area
|v_v|	   v		highlight characters or stop highlighting
|v_V|	   V		highlight linewise or stop highlighting
|v_CTRL-V| CTRL-V	highlight blockwise or stop highlighting
------------------------------------------------------------------------------
*X_to*		Text objects (only in Visual mode or after an operator)

|v_a|	N  a		Select current word
|v_A|	N  A		Select current WORD
|v_s|	N  s		Select current sentence
|v_p|	N  p		Select current paragraph
|v_S|	N  S		Select current block (from "[(" to "])")
|v_P|	N  P		Select current block (from "[{" to "]}")
------------------------------------------------------------------------------
*X_re*		Repeating commands

|.|	   N  .		repeat last change (with count replaced with N)
|q|	      q<a-z>	record typed characters into register <a-z>
|q|	      q<A-Z>	record typed characters, appended to register <a-z>
|q|	      q		stop recording
|@|	   N  @<a-z>	execute the contents of register <a-z> (N times)
|@@|	   N  @@	   repeat previous @<a-z> (N times)
|:@|	   :@<a-z>	execute the contents of register <a-z> as an Ex
			   command
|:@@|	   :@@		repeat previous :@<a-z>
|:g|	   :[range]g[lobal]/{pattern}/[cmd]
			Execute Ex command [cmd] (default: ":p") on the lines
			   within [range] where {pattern} matches.
|:g|	   :[range]g[lobal]!/{pattern}/[cmd]
			Execute Ex command [cmd] (default: ":p") on the lines
			   within [range] where {pattern} does NOT match.
|:so|	   :so[urce] {file}
			Read Ex commands from {file}.
|:so|	   :so[urce]! {file}
			Read Vim commands from {file}.
|:sl|	   :sl[eep] [N]
			don't do anything for N seconds
|gs|	   N  gs	Goto Sleep for N seconds
------------------------------------------------------------------------------
*X_km*		Key mapping

|:map|	     :ma[p] {lhs} {rhs}	  Map {lhs} to {rhs} in Normal and Visual
				     mode.
|:map!|	     :ma[p]! {lhs} {rhs}  Map {lhs} to {rhs} in Insert and Command-line
				     mode.
|:noremap|   :no[remap][!] {lhs} {rhs}
				  Same as ":map", no remapping for this {rhs}
|:unmap|     :unm[ap] {lhs}	  Remove the mapping of {lhs} for Normal and
				     Visual mode.
|:unmap!|    :unm[ap]! {lhs}	  Remove the mapping of {lhs} for Insert and
				     Command-line mode.
|:map_l|     :ma[p] [lhs]	  List mappings (starting with [lhs]) for
				     Normal and Visual mode.
|:map_l!     :ma[p]! [lhs]	  List mappings (starting with [lhs]) for
				     Insert and Command-line mode.
|:cmap|	     :cmap/:cunmap/:cnoremap
				  like ":map!"/":unmap!"/":noremap!" but for
				     Command-line mode only
|:imap|	     :imap/:iunmap/:inoremap
				  like ":map!"/":unmap!"/":noremap!" but for
				     Insert mode only
|:nmap|	     :nmap/:nunmap/:nnoremap
				  like ":map"/":unmap"/":noremap" but for
				     Normal mode only
|:vmap|	     :vmap/:vunmap/:vnoremap
				  like ":map"/":unmap"/":noremap" but for
				     Visual mode only
|:mkexrc|    :mk[exrc][!] [file]  write current mappings, abbreviations, and
				     settings to [file] (default: ".exrc";
				     use ! to overwrite)
|:mkvimrc|   :mkv[imrc][!] [file]
				  same as ":mkexrc", but with default ".vimrc"
|:mapc|      :mapc[lear]	  remove mappings for Normal and Visual mode
|:mapc|      :mapc[lear]!	  remove mappings for Insert and Cmdline mode
|:imapc|     :imapc[lear]	  remove mappings for Insert mode
|:vmapc|     :vmapc[lear]	  remove mappings for Visual mode
|:nmapc|     :nmapc[lear]	  remove mappings for Normal mode
|:cmapc|     :cmapc[lear]	  remove mappings for Cmdline mode
------------------------------------------------------------------------------
*X_ab*		Abbreviations

|:abbreviate|	:ab[breviate] {lhs} {rhs}  add abbreviation for {lhs} to {rhs}
|:abbreviate|	:ab[breviate] {lhs}	   show abbr's that start with {lhs}
|:abbreviate|	:ab[breviate]		   show all abbreviations
|:unabbreviate|	:una[bbreviate] {lhs}	   remove abbreviation for {lhs}
|:noreabbrev|	:norea[bbrev] [lhs] [rhs]  like ":ab", but don't remap [rhs]
|:iabbrev|	:iab/:iunab/:inoreab	   like ":ab", but only for Insert mode
|:cabbrev|	:cab/:cunab/:cnoreab	   like ":ab", but only for
						Command-line mode
|:abclear|	:abc[lear]		   remove all abbreviations
|:cabclear|	:cabc[lear]		   remove all abbr's for Cmdline mode
|:iabclear|	:iabc[lear]		   remove all abbr's for Insert mode
------------------------------------------------------------------------------
*X_op*		Options

|:set|	:se[t]			Show all modified options.
|:set|	:se[t] all		Show all options.
|:set|	:se[t] {option}		Set toggle option on, show string or number
				   option.
|:set|	:se[t] no{option}	Set toggle option off.
|:set|	:se[t] inv{option}	invert toggle option.
|:set|	:se[t] {option}={value} Set string or number option to {value}.
|:set|	:se[t] {option}?	Show value of {option}.
|:set|	:se[t] {option}&	Reset {option} to its default value.

|:fix|	:fix[del]		Set value of 't_kD' according to value of
				   't_kb'.

Short explanation of each option:		*option_list*
|'aleph'|	   |'al'|	ASCII code of the letter Aleph (RIGHTLEFT)
|'autoindent'|	   |'ai'|	take indent for new line from previous line
|'autowrite'|	   |'aw'|	automatically write file if changed
|'backspace'|	   |'bs'|	how backspace works at start of line
|'backup'|	   |'bk'|	keep backup file after overwriting a file
|'backupdir'|	   |'bdir'|	list of directories for the backup file
|'backupext'|	   |'bex'|	extension used for the backup file
|'binary'|	   |'bin'|	edit binary file mode
|'bioskey'|	   |'biosk'|	MS-DOS: use bios calls for input characters
|'breakat'|	   |'brk'|	characters that may cause a line break
|'cindent'|	   |'cin'|	do C program indenting
|'cinkeys'|	   |'cink'|	keys that trigger indent when 'cindent' is set
|'cinoptions'|	   |'cino'|	how to do indenting when 'cindent' is set
|'cinwords'|	   |'cinw'|	words where 'si' and 'cin' add an indent
|'cmdheight'|	   |'ch'|	number of lines to use for the command-line
|'columns'|	   |'co'|	number of columns in the display
|'comments'|	   |'com'|	patterns that can start a comment line
|'compatible'|	   |'cp'|	behave Vi-compatibly as much as possible
|'cpoptions'|	   |'cpo'|	flags for Vi-compatible behaviour
|'define'|	   |'def'|	pattern to be used to find a macro definition
|'dictionary'|	   |'dict'|	list of filenames used for keyword completion
|'digraph'|	   |'dg'|	enable the entering of digraphs in Insert mode
|'directory'|	   |'dir'|	list of directory names for the swapfile
|'edcompatible'|   |'ed'|	toggle flags of ":substitute" command
|'endofline'|	   |'eol'|	write end-of-line for last line in file
|'equalalways'|    |'ea'|	windows are automatically made the same size
|'equalprg'|	   |'ep'|	external program to use for "=" command
|'errorbells'|	   |'eb'|	ring the bell for error messages
|'errorfile'|	   |'ef'|	name of the error file for the QuickFix mode
|'errorformat'|    |'efm'|	description of the lines in the error file
|'esckeys'|	   |'ek'|	recognize function keys in Insert mode
|'expandtab'|	   |'et'|	use spaces when <Tab> is inserted
|'exrc'|			read .vimrc and .exrc in the current directory
|'formatoptions'|  |'fo'|	how automatic formatting is to be done
|'formatprg'|	   |'fp'|	name of external program used with "gq" command
|'gdefault'|	   |'gd'|	the ":substitute" flag 'g' is default on
|'guifont'|	   |'gfn'|	GUI: Name(s) of font(s) to be used
|'guioptions'|	   |'go'|	GUI: Which components and options are used
|'guipty'|			GUI: try to use a pseudo-tty for ":!" commands
|'helpfile'|	   |'hf'|	name of this help file
|'helpheight'|	   |'hh'|	minimum height of a new help window
|'hidden'|	   |'hid'|	don't unload buffer when it is abandoned
|'highlight'|	   |'hl'|	sets highlighting mode for various occasions
|'history'|	   |'hi'|	number of command-lines that are remembered
|'hkmap'|	   |'hk'|	Hebrew keyboard mapping (RIGHTLEFT)
|'icon'|			set icon of the window to the name of the file
|'ignorecase'|	   |'ic'|	ignore case in search patterns
|'include'|	   |'inc'|	pattern to be used to find an include file
|'incsearch'|	   |'is'|	highlight match while typing search pattern
|'infercase'|	   |'inf'|	adjust case of match for keyword completion
|'insertmode'|	   |'im'|	start the edit of a file in Insert mode
|'isfname'|	   |'isf'|	characters included in filenames and pathnames
|'isident'|	   |'isi'|	characters included in identifiers
|'isprint'|	   |'isp'|	printable characters
|'iskeyword'|	   |'isk'|	characters included in keywords
|'joinspaces'|	   |'js'|	two spaces after a period with a join command
|'keywordprg'|	   |'kp'|	program to use for the "K" command
|'langmap'|	   |'lmap'|	alphabetic characters for other language mode
|'laststatus'|	   |'ls'|	tells when last window has status lines
|'linebreak'|	   |'lbr'|	wrap long lines at a blank
|'lines'|			number of lines in the display
|'lisp'|			automatic indenting for Lisp
|'list'|			show <Tab> and end-of-line
|'magic'|			changes special characters in search patterns
|'makeprg'|	   |'mp'|	program to use for the ":make" command
|'maxmapdepth'|    |'mmd'|	maximum recursive depth for mapping
|'maxmem'|	   |'mm'|	maximum memory (in Kbyte) used for one buffer
|'maxmemtot'|	   |'mmt'|	maximum memory (in Kbyte) used for all buffers
|'modeline'|	   |'ml'|	recognize modelines at start or end of file
|'modelines'|	   |'mls'|	number of lines checked for modelines
|'modified'|	   |'mod'|	buffer has been modified
|'more'|			pause listings when the whole screen is filled
|'mouse'|			enable the use of mouse clicks
|'mousetime'|	   |'mouset'|	max time between mouse double-click
|'number'|	   |'nu'|	print the line number in front of each line
|'paragraphs'|	   |'para'|	nroff macros that separate paragraphs
|'paste'|			allow pasting text
|'patchmode'|	   |'pm'|	keep the oldest version of a file
|'path'|	   |'pa'|	list of directories searched with "gf" et.al.
|'readonly'|	   |'ro'|	disallow writing the buffer
|'remap'|			allow mappings to work recursively
|'report'|			threshold for reporting nr. of lines changed
|'restorescreen'|  |'rs'|	Win32: restore screen when exiting
|'revins'|	   |'ri'|	inserting characters will work backwards
|'rightleft'|	   |'rl'|	window is right-to-left oriented (RIGHTLEFT)
|'ruler'|	   |'ru'|	show cursor line and column in the status line
|'scroll'|	   |'scr'|	lines to scroll with CTRL-U and CTRL-D
|'scrolljump'|	   |'sj'|	minimum number of lines to scroll
|'scrolloff'|	   |'so'|	minimum nr. of lines above and below cursor
|'sections'|	   |'sect'|	nroff macros that separate sections
|'secure'|			secure mode for reading .vimrc in current dir
|'shell'|	   |'sh'|	name of shell to use for external commands
|'shellcmdflag'|   |'shcf'|	flag to shell to execute one command
|'shellpipe'|	   |'sp'|	string to put output of ":make" in error file
|'shellquote'|	   |'shq'|	quote character(s) for around shell command
|'shellredir'|	   |'srr'|	string to put output of filter in a temp file
|'shelltype'|	   |'st'|	Amiga: influences how to use a shell
|'shiftround'|	   |'sr'|	round indent to multiple of shiftwidth
|'shiftwidth'|	   |'sw'|	number of spaces to use for (auto)indent step
|'shortmess'|	   |'shm'|	list of flags, reduce length of messages
|'shortname'|	   |'sn'|	non-MS-DOS: File names assumed to be 8.3 chars
|'showbreak'|	   |'sbr'|	string to use at the start of wrapped lines
|'showcmd'|	   |'sc'|	show (partial) command in status line
|'showmatch'|	   |'sm'|	briefly jump to matching bracket if insert one
|'showmode'|	   |'smd'|	message on status line to show current mode
|'sidescroll'|	   |'ss'|	minimum number of columns to scroll horizontal
|'smartcase'|	   |'scs'|	no ignore case when pattern has uppercase
|'smartindent'|    |'si'|	smart autoindenting for C programs
|'smarttab'|	   |'sta'|	use 'shiftwidth' when inserting <Tab>
|'splitbelow'|	   |'sb'|	new window from split is below the current one
|'startofline'|    |'sol'|	commands move cursor to first blank in line
|'suffixes'|	   |'su'|	suffixes that are ignored with multiple match
|'swapsync'|	   |'sws'|	how to sync swapfile
|'tabstop'|	   |'ts'|	number of spaces that <Tab> in file uses
|'taglength'|	   |'tl'|	number of significant characters for a tag
|'tagrelative'|    |'tr'|	filenames in tag file are relative
|'tags'|	   |'tag'|	list of filenames used by the tag command
|'term'|			name of the terminal
|'terse'|			shorten some messages
|'textauto'|	   |'ta'|	set 'textmode' automatically when reading file
|'textmode'|	   |'tx'|	lines are separated by <CR><NL>
|'textwidth'|	   |'tw'|	maximum width of text that is being inserted
|'tildeop'|	   |'top'|	tilde command "~" behaves like an operator
|'timeout'|	   |'to'|	time out on mappings and key codes
|'ttimeout'|			time out on mappings
|'timeoutlen'|	   |'tm'|	time out time in milliseconds
|'ttimeoutlen'|	   |'ttm'|	time out time for key codes in milliseconds
|'title'|			set title of window to the name of the file
|'ttybuiltin'|	   |'tbi'|	use built-in termcap before external termcap
|'ttyfast'|	   |'tf'|	indicates a fast terminal connection
|'ttyscroll'|	   |'tsl'|	maximum number of lines for a scroll
|'ttytype'|	   |'tty'|	alias for 'term'
|'undolevels'|	   |'ul'|	maximum number of changes that can be undone
|'updatecount'|    |'uc'|	after this many characters flush swapfile
|'updatetime'|	   |'ut'|	after this many milliseconds flush swapfile
|'viminfo'|	   |'vi'|	use .viminfo file upon startup and exiting
|'visualbell'|	   |'vb'|	use visual bell instead of beeping
|'warn'|			warn for shell command when buffer was changed
|'weirdinvert'|    |'wi'|	for terminals that have weird inversion method
|'whichwrap'|	   |'ww'|	allow specified keys to cross line boundaries
|'wildchar'|	   |'wc'|	command-line character for wildcard expansion
|'winheight'|	   |'wh'|	minimum number of lines for the current window
|'wrap'|			long lines wrap and continue on the next line
|'wrapmargin'|	   |'wm'|	chars from the right where wrapping starts
|'wrapscan'|	   |'ws'|	searches wrap around the end of the file
|'writeany'|	   |'wa'|	write to file with no need for "!" override
|'writebackup'|    |'wb'|	make a backup before overwriting a file
|'writedelay'|	   |'wd'|	delay this many msec for each char (for debug)
------------------------------------------------------------------------------
*X_ur*		Undo/Redo commands

|u|	  N  u		undo last N changes
|CTRL-R|  N  CTRL-R	redo last N undone changes
|U|	     U		restore last changed line
------------------------------------------------------------------------------
*X_et*		External commands

|:shell|	:sh[ell]	start a shell
|:!|		:!{command}	execute {command} with a shell
|K|		   K		lookup keyword under the cursor with
				   'keywordprg' program (default: "man")
------------------------------------------------------------------------------
*X_qf*		Quickfix commands

|:cc|		:cc [nr]	display error [nr] (default is the same again)
|:cnext|	:cn		display the next error
|:cprevious|	:cp		display the previous error
|:clist|	:cl		list all errors
|:cfile|	:cf		read errors from the file 'errorfile'
|:cquit|	:cq		quit without writing and return error code (to
				   the compiler)
|:make|		:make [args]	start make, read errors, and jump to first
				   error
------------------------------------------------------------------------------
*X_vc*		Various commands

|CTRL-L|	   CTRL-L	Clear and redraw the screen.
|CTRL-G|	   CTRL-G	show current file name (with path) and cursor
				   position
|ga|		   ga		show ascii value of character under cursor in
				   decimal, hex, and octal
|g_CTRL-G|	   g CTRL-G	show cursor column, line, and character
				   position
|CTRL-C|	   CTRL-C	during searches: interrupt the search
|CTRL-BREAK|	   CTRL-BREAK	MS-DOS: during searches: interrupt the search
|<Del>|		   <Del>	while entering a count: delete last character
|:version|	:ve[rsion]	show exact version number of this Vim
|:mode|		:mode N		MS-DOS: set screen mode to N (number, C80,
				   C4350, etc.)
|:normal|	:norm[al][!] {commands}
				Execute Normal mode commands.
------------------------------------------------------------------------------
*X_ce*		Command-line editing

|c_<Esc>|	<Esc>		   abandon command-line (if 'wildchar' is
				      <Esc>, type it twice)

|c_CTRL-V|	CTRL-V {char}	   insert {char} literally
|c_CTRL-V|	CTRL-V {number}    enter decimal value of character (up to
				      three digits)
|c_CTRL-K|	CTRL-K {char1} {char2}
				   enter digraph (See |X_di|)
|c_CTRL-R|	CTRL-R <0-9a-z"%:->
				   insert contents of register <0-9a-z"%:->

|c_<Left>|	<Left>/<Right>	   cursor left/right
|c_<S-Left>|	<S-Left>/<S-Right> cursor one word left/right
|c_CTRL-B|	CTRL-B/CTRL-E	   cursor to beginning/end of command-line

|c_<BS>|	<BS>		   delete the character in front of the cursor
|c_<Del>|	<Del>		   delete the character under the cursor
|c_CTRL-W|	CTRL-W		   delete the word in front of the cursor
|c_CTRL-U|	CTRL-U		   remove all characters

|c_<Up>|	<Up>/<Down>	   recall older/newer command-line that starts
				      with current command
|c_<S-Up>|	<S-Up>/<S-Down>	   recall older/newer command-line from history

	Context-sensitive completion on the command-line:

|c_wildchar|	'wildchar'  (default: <Tab>)
				do completion on the pattern in front of the
				   cursor.  If there are multiple matches,
				   beep and show the first one; further
				   'wildchar' will show the next ones.
|c_CTRL-D|	CTRL-D		list all names that match the pattern in
				   front of the cursor
|c_CTRL-A|	CTRL-A		insert all names that match pattern in front
				   of cursor
|c_CTRL-L|	CTRL-L		insert longest common part of names that
				   match pattern
|c_CTRL-N|	CTRL-N		after 'wildchar' with multiple matches: go
				   to next match
|c_CTRL-P|	CTRL-P		after 'wildchar' with multiple matches: go
				   to previous match
------------------------------------------------------------------------------
*X_ra*		Ex ranges

|:range|	,		separates two line numbers
|:range|	;		idem, set cursor to the first line number
				before interpreting the second one

|:range|	{number}	an absolute line number
|:range|	.		the current line
|:range|	$		the last line in the file
|:range|	%		equal to 1,$ (the entire file)
|:range|	*		equal to '<,'> (visual area)
|:range|	't		position of mark t
|:range|	/{pattern}	the next line where {pattern} matches
|:range|	?{pattern}	the previous line where {pattern} matches

|:range|	+[num]		add [num] to the preceding line number
				   (default: 1)
|:range|	-[num]		subtract [num] from the preceding line
				   number (default: 1)
------------------------------------------------------------------------------
*X_ex*		Special Ex characters

|:bar|	    |		separates two commands (not for ":global" and ":!")
|:quote|    "		begins comment

|:_%|	    %		current filename (only where filename is expected)
|:_#|	    #[number]	alternate filename [number] (only where filename is
			   expected)
	Note: The next four are typed literally; these are not special keys!
|:<cword>|  <cword>	word under the cursor (only where filename is
			   expected)
|:<cWORD>|  <cWORD>	WORD under the cursor (only where filename is
			   expected) (see |WORD|)
|:<cfile>|  <cfile>	file name under the cursor (only where filename is
			   expected)
|:<afile>|  <afile>	file name for autocommand (only where filename is
			   expected)

			After "%", "#", "<cfile>", or "<afile>"
			|::p|	    :p		full path
			|::h|	    :h		head
			|::t|	    :t		tail
			|::r|	    :r		root
			|::e|	    :e		extension
------------------------------------------------------------------------------
*X_ed*		Editing a file

|:edit|	   :e[dit]		Edit the current file, unless changes have
				   been made.
|:edit!|   :e[dit]!		Edit the current file always.  Discard any
				   changes.
|:edit_f|  :e[dit] {file}	Edit {file}, unless changes have been made.
|:edit!_f| :e[dit]! {file}	Edit {file} always.  Discard any changes.
|CTRL-^|   N   CTRL-^		Edit alternate file N (equivalent to ":e #N").
|gf|	       gf  or ]f	Edit the file whose name is under the cursor
|:pwd|	   :pwd			Print the current directory name.
|:cd|	   :cd [path]		Change the current directory to [path].
|:file|	   :f[ile]		Print the current filename and the cursor
				   position.
|:file|	   :f[ile] {name}	Set the current filename to {name}.
|:files|   :files		Show alternate filenames.
------------------------------------------------------------------------------
*X_fl*		Using the argument list			|argument_list|

|:args|	   :ar[gs]		Print the argument list, with the current file
				   in "[]".
|:all|	   :all  or :sall	Open a window for every file in the arg list.
|:wn|	   :wn[ext][!]		Write file and edit next file.
|:wn|	   :wn[ext][!] {file}	Write to {file} and edit next file, unless
				   {file} exists.  With !, overwrite existing
				   file.
|:wN|	   :wN[ext][!] [file]	Write file and edit previous file.

	       in current window    in new window
|:argument|  :argu[ment] N	  :sar[gument] N	Edit file N
|:next|	     :n[ext]		  :sn[ext]		Edit next file
|:next_f|    :n[ext] {arglist}	  :sn[ext] {arglist}	define new arg list
							   and edit first file
|:Next|	     :N[ext]		  :sN[ext]		Edit previous file
|:rewind|    :rew[ind][!]	  :srew[ind]		Edit first file
|:last|	     :last		  :slast		Edit last file
------------------------------------------------------------------------------
*X_wq*		Writing and quitting

|:w|	  :[range]w[rite][!]		Write to the current file.
|:w_f|	  :[range]w[rite] {file}	Write to {file}, unless it already
					   exists.
|:w_f|	  :[range]w[rite]! {file}	Write to {file}.  Overwrite an existing
					   file.
|:w_a|	  :[range]w[rite][!] >>		Append to the current file.
|:w_a|	  :[range]w[rite][!] >> {file}	Append to {file}.
|:w_c|	  :[range]w[rite] !{cmd}	Execute {cmd} with [range] lines as
					   standard input.
|:wall|	  :wall[!]			write all changed buffers

|:q|	  :q[uit]		Quit current buffer, unless changes have been
				   made.  Exit Vim when there are no other
				   non-help buffers
|:q|	  :q[uit]!		Quit current buffer always, discard any
				   changes.  Exit Vim when there are no other
				   non-help buffers
|:qa|	  :qall			Exit Vim, unless changes have been made.
|:qa|	  :qall!		Exit Vim always, discard any changes.
|:cq|	  :cq			Quit without writing and return error code.

|:wq|	  :wq[!]		Write the current file and exit.
|:wq|	  :wq[!] {file}		Write to {file} and exit.
|:xit|	  :x[it][!] [file]	Like ":wq" but write only when changes have
				   been made
|ZZ|	     ZZ			Same as ":x".
|ZQ|	     ZQ			Same as ":q!".
|:xall|	  :xall[!]  or :wqall[!]
				Write all changed buffers and exit

|:stop|	  :st[op][!]		Suspend VIM or start new shell. If 'aw' option
				   is set and [!] not given write the buffer.
|CTRL-Z|     CTRL-Z		Same as ":stop!"
------------------------------------------------------------------------------
*X_st*		Starting VIM

|-vim|	   vim [options]		start editing with an empty buffer
|-file|	   vim [options] {file ..}	start editing one or more files
|-tag|	   vim [options] -t {tag}	edit the file associated with {tag}
|-qf|	   vim [options] -e [fname]	start editing in QuickFix mode,
					   display the first error

	Vim arguments:

|-gui|	-g		    start GUI (also allows other options)

|-+|	+[num]		    put the cursor at line [num] (default: last line)
|-+c|	+{command}	    execute {command} after loading the file
|-+/|	+/{pat} {file ..}   put the cursor at the first occurrence of {pat}
|-v|	-v		    read-only mode (View), implies -n
|-R|	-R		    read-only mode, same as -v
|-b|	-b		    binary mode
|-l|	-l		    lisp mode
|-H|	-H		    Hebrew mode ('hkmap' and 'rightleft' are set)
|-r|	-r		    give list of swap files
|-r|	-r {file ..}	    recover aborted edit session
|-n|	-n		    do not create swapfile
|-o|	-o [N]		    open N windows (default: one for each file)
|-x|	-x		    Amiga: do not restart VIM to open a window (for
				e.g., mail)
|-s|	-s {scriptin}	    first read commands from the file {scriptin}
|-w|	-w {scriptout}	    write typed chars to file {scriptout} (append)
|-W|	-W {scriptout}	    write typed chars to file {scriptout} (overwrite)
|-T|	-T {terminal}	    set terminal name
|-d|	-d {device}	    Amiga: open {device} to be used as a console
|-u|	-u {vimrc}	    read inits from {vimrc} instead of other inits
|-i|	-i {viminfo}	    read info from {viminfo} instead of other files
|--|	--		    end of options, other arguments are file names
------------------------------------------------------------------------------
*X_ac*		Automatic Commands

|viminfo_file|	Read registers, marks, history at startup, save when exiting.

|:rviminfo|	:rv[iminfo] [file]	Read info from viminfo file [file]
|:rviminfo|	:rv[iminfo]! [file]	idem, overwrite exisiting info
|:wviminfo|	:wv[iminfo] [file]	Add info to viminfo file [file]
|:wviminfo|	:wv[iminfo]! [file]	Write info to viminfo file [file]

|modeline|	Automatic option setting when editing a file

|modeline|	vim:{set-arg}: ..	In the first and last lines of the
					file (see 'ml' option), {set-arg} is
					given as an argument to ":set"

|autocommand|	Automatic execution of commands on certain events.

|:autocmd|	:au			List all autocommands
|:autocmd|	:au {event}		List all autocommands for {event}
|:autocmd|	:au {event} {pat}	List all autocommands for {event} with
					{pat}
|:autocmd|	:au {event} {pat} {cmd}	Enter new autocommands for {event}
					with {pat}
|:autocmd|	:au!			Remove all autocommands
|:autocmd|	:au! {event}		Remove all autocommands for {event}
|:autocmd|	:au! * {pat}		Remove all autocommands for {pat}
|:autocmd|	:au! {event} {pat}	Remove all autocommands for {event}
					with {pat}
|:autocmd|	:au! {event} {pat} {cmd}  Remove all autocommands for {event}
					with {pat} and enter new one
------------------------------------------------------------------------------
*X_wi*		Multi-window functions

|CTRL-W_s|	CTRL-W s  or  :split	Split window into two parts
|:split_f|	:split {file}		Split window and edit {file} in one of
					   them
|CTRL-W_]|	CTRL-W ]		Split window and jump to tag under
					   cursor
|CTRL-W_f|	CTRL-W f		Split window and edit file name under
					   the cursor
|CTRL-W_CTRL-^| CTRL-W CTRL-^		Split window and edit alternate file
|CTRL-W_n|	CTRL-W n  or  :new	Create new empty window
|CTRL-W_q|	CTRL-W q  or  :q[uit]	Quit editing and close window
|CTRL-W_c|	CTRL-W c  or  :cl[ose]	Make buffer hidden and close window
|CTRL-W_o|	CTRL-W o  or  :on[ly]	Make current window only one on the
					   screen

|CTRL-W_j|	CTRL-W j		Move cursor to window below
|CTRL-W_k|	CTRL-W k		Move cursor to window above
|CTRL-W_CTRL-W|	CTRL-W CTRL-W		Move cursor to window below (wrap)
|CTRL-W_W|	CTRL-W W		Move cursor to window above (wrap)
|CTRL-W_t|	CTRL-W t		Move cursor to top window
|CTRL-W_b|	CTRL-W b		Move cursor to bottom window
|CTRL-W_p|	CTRL-W p		Move cursor to previous active window

|CTRL-W_r|	CTRL-W r		Rotate windows downwards
|CTRL-W_R|	CTRL-W R		Rotate windows upwards
|CTRL-W_x|	CTRL-W x		Exchange current window with next one

|CTRL-W_=|	CTRL-W =		Make all windows equal height
|CTRL-W_-|	CTRL-W -		Decrease current window height
|CTRL-W_+|	CTRL-W +		Increase current window height
|CTRL-W__|	CTRL-W _		Set current window height (default:
					   very high)
------------------------------------------------------------------------------
*X_bu*		Buffer list functions

|:buffers|	:buffers  or  :files	list all known buffer and file names

|:ball|		:ball	  or  :sball	edit all args/buffers
|:unhide|	:unhide   or  :sunhide	edit all loaded buffers

|:bunload|	:bunload[!] [N]		unload buffer [N] from memory
|:bdelete|	:bdelete[!] [N]		unload buffer [N] and delete it from
					   the buffer list

	        in current window   in new window
|:buffer|     :[N]buffer [N]	  :[N]sbuffer [N]     to arg/buf N
|:bnext|      :[N]bnext [N]	  :[N]sbnext [N]      to Nth next arg/buf
|:bNext|      :[N]bNext [N]	  :[N]sbNext [N]      to Nth previous arg/buf
|:bprevious|  :[N]bprevious [N]   :[N]sbprevious [N]  to Nth previous arg/buf
|:brewind|    :brewind		  :sbrewind	      to first arg/buf
|:blast|      :blast		  :sblast	      to last arg/buf
|:bmodified|  :[N]bmod [N]	  :[N]sbmod [N]	      to Nth modified buf
------------------------------------------------------------------------------
*bars*		Bars example

Now that you've jumped here with CTRL-], g<LeftMouse>, or <C-LeftMouse>, you
can use CTRL-T, g<RightMouse>, or <C-RightMouse> to go back to where you were.
------------------------------------------------------------------------------

			*www* *faq* *FAQ* *ftp* *distribution* *download*
The Vim pages contain the most recent information about Vim.  They also
contains links to the most recent version of Vim.  The FAQ is a list of
Frequently Asked Questions, read this if you have problems.

	VIM home page:	<URL:http://www.math.fu-berlin.de/~guckes/vim/>
	VIM FAQ:	<URL:http://www.grafnetix.com/~laurent/vim/>

Bug reports:							*bugs*
	Bram Moolenaar <mool@oce.nl>
Please be brief; all the time that is spend on answering mail is subtracted
from the time that is spent on improving Vim!  Always give a reproducible
example and try to find out which settings or other things influence the
appearance of the bug.  Try different machines, if possible.  Send me patches
if you can!  In case of doubt, include the output of these commands:
	:version
	:!uname -a	" Unix only
	:map
	:map!
	:au
	:set all
	:set termcap

Usenet News group where Vim is discussed:		*news* *usenet*
	comp.editors

							*vimdev* *mail_list*
There are three mailing lists for Vim:
<vim@prz.tu-berlin.de>		For discussions about using existing versions
				of Vim: Useful mappings, questions, answers,
				where to get a specific version, etc.
<vimdev@prz.tu-berlin.de>	For discussions about changing Vim: New
				features, porting, etc.
<vimannounce@prz.tu-berlin.de>	Announcements about new versions of Vim; also
				beta-test versions and ports to different
				systems.

NOTE: You can only send messages to these lists if you have subscribed!  Also:
you need to send the messages from the same location as the one you subscribed
from (yes, Majordomo is inflexible).

If you want to join, send a message to
	<majordomo@prz.tu-berlin.de>
and put "info" in the body.  Then Majordomo will give you a little help.

An archive is kept at:
<URL:ftp://ftp.ii.uib.no/pub/vim/mail-archive/vim/maillist.html>
<URL:ftp://ftp.ii.uib.no/pub/vim/mail-archive/vimdev/maillist.html>
<URL:ftp://ftp.ii.uib.no/pub/vim/mail-archive/vimannounce/maillist.html>

*credits* *author*

Most of Vim was written by Bram Moolenaar <mool@oce.nl>.

Parts of the documentation come from several Vi manuals, written by:
	W.N. Joy
	Alan P.W. Hewett
	Mark Horton

The Vim editor is based on Stevie and includes (ideas from) other software,
worked on by the people mentioned here.  Other people helped by giving me
suggestions and discussing what is good and bad in Vim.

	Tony Andrews		Stevie
	Gert van Antwerpen	changes for DJGPP on MS-DOS
	Berkeley DB(3)		ideas for swapfile
	Keith Bostic		Nvi
	Ralf Brown		SPAWNO library for MS-DOS
	Robert Colon		many useful remarks
	Kayhan Demirel		sent me news in Uganda
	Chris & John Downey	xvi (ideas for multi-windows version)
	Eric Fischer		Mac port, 'cindent', and other improvements
	Bill Foster		Athena GUI port
	Loic Grenie		xvim (ideas for multi windows version)
	Steve Kirkendall	Elvis
	Sergey Laskavy		Vim's help from Moscow
	Avner Lottem		Edit in right-to-left windows (RIGHTLEFT)
	George V. Reilly	Win32 port
	Stephen Riehm		bug collector
	Olaf Seibert		DICE version and regexp improvements
	Peter da Silva		termlib
	Paul Slootman		OS/2 port
	Henry Spencer		regular expressions
	Tim Thompson		Stevie
	G. R. (Fred) Walter	Stevie
	Robert Webb		Command-line completion, GUI version, and lots
				of patches
	Juergen Weigert		Lattice version, AUX improvements, UNIX and
				MS-DOS ports, autoconf

I wish to thank all the people that sent me bug reports and suggestions.  The
list is too long to mention them all here.  Vim would not be the same without
the ideas from all these people: they keep Vim alive!

 vim:ts=8:sw=8:js:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":
