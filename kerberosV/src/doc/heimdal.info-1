This is heimdal.info, produced by makeinfo version 4.0 from
heimdal.texi.

INFO-DIR-SECTION Heimdal
START-INFO-DIR-ENTRY
* Heimdal: (heimdal).           The Kerberos 5 distribution from KTH
END-INFO-DIR-ENTRY


File: heimdal.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Heimdal
*******

* Menu:

* Introduction::
* What is Kerberos?::
* Building and Installing::
* Setting up a realm::
* Applications::
* Things in search for a better place::
* Kerberos 4 issues::
* Windows 2000 compatability::
* Programming with Kerberos::
* Migration::
* Acknowledgments::


File: heimdal.info,  Node: Introduction,  Next: What is Kerberos?,  Prev: Top,  Up: Top

Introduction
************

What is Heimdal?
================

Heimdal is a free implementation of Kerberos 5. The goals are to:

   * have an implementation that can be freely used by anyone

   * be protocol compatible with existing implementations and, if not in
     conflict, with RFC 1510 (and any future updated RFC)

   * be reasonably compatible with the M.I.T Kerberos V5 API

   * have support for Kerberos V5 over GSS-API (RFC1964)

   * include the most important and useful application programs (rsh,
     telnet, popper, etc.)

   * include enough backwards compatibility with Kerberos V4

Status
======

Heimdal has the following features (this does not mean any of this
works):

   * a stub generator and a library to encode/decode/whatever ASN.1/DER
     stuff

   * a `libkrb5' library that should be possible to get to work with
     simple applications

   * a GSS-API library that should have all the important functions for
     building applications

   * Eric Young's `libdes'

   * `kinit', `klist', `kdestroy'

   * `telnet', `telnetd'

   * `rsh', `rshd'

   * `popper', `push' (a movemail equivalent)

   * `ftp', and `ftpd'

   * a library `libkafs' for authenticating to AFS and a program
     `afslog' that uses it

   * some simple test programs

   * a KDC that supports most things; optionally, it may also support
     Kerberos V4 and kaserver,

   * simple programs for distributing databases between a KDC master and
     slaves

   * a password changing daemon `kpasswdd', library functions for
     changing passwords and a simple client

   * some kind of administration system

   * Kerberos V4 support in many of the applications.

Bug reports
===========

If you find bugs in this software, make sure it is a genuine bug and not
just a part of the code that isn't implemented.

Bug reports should be sent to <heimdal-bugs@pdc.kth.se>. Please include
information on what machine and operating system (including version)
you are running, what you are trying to do, what happens, what you
think should have happened, an example for us to repeat, the output you
get when trying the example, and a patch for the problem if you have
one. Please make any patches with `diff -u' or `diff -c'.

Suggestions, comments and other non bug reports are also welcome.

Mailing list
============

There are two mailing lists with talk about Heimdal.
<heimdal-announce@sics.se> is a low-volume announcement list, while
<heimdal-discuss@sics.se> is for general discussion.  Send a message to
<majordomo@sics.se> to subscribe.

Heimdal source code, binaries and the manual
============================================

The source code for heimdal, links to binaries and the manual (this
document) can be found on our web-page at
<http://www.pdc.kth.se/heimdal/>.


File: heimdal.info,  Node: What is Kerberos?,  Next: Building and Installing,  Prev: Introduction,  Up: Top

What is Kerberos?
*****************

     Now this Cerberus had three heads of dogs,
             the tail of a dragon, and on his back the
             heads of all sorts of snakes.
             -- Pseudo-Apollodorus Library 2.5.12

Kerberos is a system for authenticating users and services on a network.
It is built upon the assumption that the network is "unsafe".  For
example, data sent over the network can be eavesdropped and altered, and
addresses can also be faked.  Therefore they cannot be used for
authentication purposes.

Kerberos is a trusted third-party service.  That means that there is a
third party (the kerberos server) that is trusted by all the entities on
the network (users and services, usually called "principals").  All
principals share a secret password (or key) with the kerberos server and
this enables principals to verify that the messages from the kerberos
server are authentic.  Thus trusting the kerberos server, users and
services can authenticate each other.

Basic mechanism
===============

     *Note* This discussion is about Kerberos version 4, but version 5
     works similarly.

In Kerberos, principals use "tickets" to prove that they are who they
claim to be. In the following example, A is the initiator of the
authentication exchange, usually a user, and B is the service that A
wishes to use.

To obtain a ticket for a specific service, A sends a ticket request to
the kerberos server. The request contains A's and B's names (along with
some other fields). The kerberos server checks that both A and B are
valid principals.

Having verified the validity of the principals, it creates a packet
containing A's and B's names, A's network address (A<ADDR>), the
current time (T<ISSUE>), the lifetime of the ticket (LIFE), and a
secret "session key" (K<AB>). This packet is encrypted with B's secret
key (K<B>).  The actual ticket (T<AB>) looks like this: ({A, B,
A<ADDR>, T<ISSUE>, LIFE, K<AB>}K<B>).

The reply to A consists of the ticket (T<AB>), B's name, the current
time, the lifetime of the ticket, and the session key, all encrypted in
A's secret key ({B, T<ISSUE>, LIFE, K<AB>, T<AB>}K<A>). A decrypts the
reply and retains it for later use.


Before sending a message to B, A creates an authenticator consisting of
A's name, A's address, the current time, and a "checksum" chosen by A,
all encrypted with the secret session key ({A, A<ADDR>, T<CURRENT>,
CHECKSUM}K<AB>). This is sent together with the ticket received from
the kerberos server to B.  Upon reception, B decrypts the ticket using
B's secret key.  Since the ticket contains the session key that the
authenticator was encrypted with, B can now also decrypt the
authenticator. To verify that A really is A, B now has to compare the
contents of the ticket with that of the authenticator. If everything
matches, B now considers A as properly authenticated.

Different attacks
=================

Impersonating A
---------------

An impostor, C could steal the authenticator and the ticket as it is
transmitted across the network, and use them to impersonate A. The
address in the ticket and the authenticator was added to make it more
difficult to perform this attack.  To succeed C will have to either use
the same machine as A or fake the source addresses of the packets. By
including the time stamp in the authenticator, C does not have much
time in which to mount the attack.

Impersonating B
---------------

C can hijack B's network address, and when A sends her credentials, C
just pretend to verify them. C can't be sure that she is talking to A.

Defense strategies
==================

It would be possible to add a "replay cache" to the server side.  The
idea is to save the authenticators sent during the last few minutes, so
that B can detect when someone is trying to retransmit an already used
message. This is somewhat impractical (mostly regarding efficiency),
and is not part of Kerberos 4; MIT Kerberos 5 contains it.

To authenticate B, A might request that B sends something back that
proves that B has access to the session key. An example of this is the
checksum that A sent as part of the authenticator. One typical
procedure is to add one to the checksum, encrypt it with the session
key and send it back to A.  This is called "mutual authentication".

The session key can also be used to add cryptographic checksums to the
messages sent between A and B (known as "message integrity").
Encryption can also be added ("message confidentiality"). This is
probably the best approach in all cases.

Further reading
===============

The original paper on Kerberos from 1988 is `Kerberos: An
Authentication Service for Open Network Systems', by Jennifer Steiner,
Clifford Neuman and Jeffrey I. Schiller.

A less technical description can be found in `Designing an
Authentication System: a Dialogue in Four Scenes' by Bill Bryant, also
from 1988.

These documents can be found on our web-page at
<http://www.pdc.kth.se/kth-krb/>.


File: heimdal.info,  Node: Building and Installing,  Next: Setting up a realm,  Prev: What is Kerberos?,  Up: Top

Building and Installing
***********************

Heimdal uses GNU Autoconf to configure for specific hosts, and GNU
Automake to manage makefiles. If this is new to you, the short
instruction is to run the `configure' script in the top level
directory, and when that finishes `make'.

If you want to build the distribution in a different directory from the
source directory, you will need a make that implements VPATH correctly,
such as GNU make.

You will need to build the distribution:

   * A compiler that supports a "loose" ANSI C mode, such as `gcc'.

   * lex or flex

   * awk

   * yacc or bison

   * a socket library

   * NDBM or Berkeley DB for building the server side.

When everything is built, you can install by doing `make install'. The
default location for installation is `/usr/heimdal', but this can be
changed by running `configure' with `--prefix=/some/other/place'.

If you need to change the default behavior, configure understands the
following options:

`--without-berkeley-db'
     DB is preferred before NDBM, but if you for some reason want to
     use NDBM instead, you can use this option.

`--with-krb4=`dir''
     Gives the location of Kerberos 4 libraries and headers. This
     enables Kerberos 4 support in the applications (telnet, rsh,
     popper, etc) and the KDC. It is automatically check for in
     `/usr/athena'. If you keep libraries and headers in different
     places, you can instead give the path to each with the
     `--with-krb4-lib=`dir'', and `--with-krb4-include=`dir'' options.

     You will need a fairly recent version of our Kerberos 4
     distribution for `rshd' and `popper' to support version 4 clients.

`--enable-dce'
     Enables support for getting DCE credentials and tokens.  See the
     README files in `appl/dceutils' for more information.

`--disable-otp'
     By default some of the application programs will build with
     support for one-time passwords (OTP).  Use this option to disable
     that support.

`--enable-osfc2'
     Enable some C2 support for OSF/Digital Unix/Tru64.  Use this
     option if you are running your OSF operating system in C2 mode.

`--with-readline=`dir''
     Gives the path for the GNU Readline library, which will be used in
     some programs. If no readline library is found, the (simpler)
     editline library will be used instead.

`--with-hesiod=`dir''
     Enables hesiod support in push.

`--enable-netinfo'
     Add support for using netinfo to lookup configuration information.
     Probably only useful (and working) on NextStep/Mac OS X.

`--without-ipv6'
     Disable the IPv6 support.

`--with-openldap'
     Compile Heimdal with support for storing the database in LDAP.
     Requires OpenLDAP <http://www.openldap.org>.  See
     <http://www.padl.com/Research/Heimdal.html> for more information.

`--enable-bigendian'

`--enable-littleendian'
     Normally, the build process will figure out by itself if the
     machine is big or little endian.  It might fail in some cases when
     cross-compiling.  If it does fail to figure it out, use the
     relevant of these two options.

`--with-mips-abi=ABI'
     On Irix there are three different ABIs that can be used (`32',
     `n32', or `64').  This option allows you to override the automatic
     selection.

`--disable-mmap'
     Do not use the mmap system call.  Normally, configure detects if
     there is a working mmap and it is only used if there is one.  Only
     try this option if it fails to work anyhow.


File: heimdal.info,  Node: Setting up a realm,  Next: Applications,  Prev: Building and Installing,  Up: Top

Setting up a realm
******************

* Menu:

* Configuration file::
* Creating the database::
* Modifying the database::
* keytabs::
* Serving Kerberos 4/524/kaserver::
* Remote administration::
* Password changing::
* Testing clients and servers::
* Slave Servers::
* Incremental propagation::
* Salting::
* Cross realm::
* Transit policy::
* Setting up DNS::
* Using LDAP to store the database::
* Providing Kerberos credentials to servers and programs::

A realm is an administrative domain.  The name of a Kerberos realm is
usually the Internet domain name in uppercase.  Call your realm the same
as your Internet domain name if you do not have strong reasons for not
doing so.  It will make life easier for you and everyone else.


File: heimdal.info,  Node: Configuration file,  Next: Creating the database,  Prev: Setting up a realm,  Up: Setting up a realm

Configuration file
==================

To setup a realm you will first have to create a configuration file:
`/etc/krb5.conf'. The `krb5.conf' file can contain many configuration
options, some of which are described here.

There is a sample `krb5.conf' supplied with the distribution.

The configuration file is a hierarchical structure consisting of
sections, each containing a list of bindings (either variable
assignments or subsections). A section starts with `[`section-name']'.
A binding consists of a left hand side, an equal (`=') and a right hand
side (the left hand side tag must be separated from the equal with some
whitespace). Subsections has a `{' as the first non-whitespace
character after the equal. All other bindings are treated as variable
assignments. The value of a variable extends to the end of the line.

     [section1]
             a-subsection = {
                     var = value1
                     other-var = value with {}
                     sub-sub-section = {
                             var = 123
                     }
             }
             var = some other value
     [section2]
             var = yet another value

In this manual, names of sections and bindings will be given as strings
separated by slashes (`/'). The `other-var' variable will thus be
`section1/a-subsection/other-var'.

For in-depth information about the contents of the configuration file,
refer to the `krb5.conf' manual page. Some of the more important
sections are briefly described here.

The `libdefaults' section contains a list of library configuration
parameters, such as the default realm and the timeout for KDC
responses. The `realms' section contains information about specific
realms, such as where they hide their KDC. This section serves the same
purpose as the Kerberos 4 `krb.conf' file, but can contain more
information. Finally the `domain_realm' section contains a list of
mappings from domains to realms, equivalent to the Kerberos 4
`krb.realms' file.

To continue with the realm setup, you will have to create a
configuration file, with contents similar to the following.

     [libdefaults]
             default_realm = MY.REALM
     [realms]
             MY.REALM = {
                     kdc = my.kdc my.slave.kdc
                     kdc = my.third.kdc
             }
     [domain_realm]
             .my.domain = MY.REALM

If you use a realm name equal to your domain name, you can omit the
`libdefaults', and `domain_realm', sections. If you have a DNS
SRV-record for your realm, or your Kerberos server has DNS CNAME
`kerberos.my.realm', you can omit the `realms' section too.


File: heimdal.info,  Node: Creating the database,  Next: Modifying the database,  Prev: Configuration file,  Up: Setting up a realm

Creating the database
=====================

The database library will look for the database in the directory
`/var/heimdal', so you should probably create that directory.  Make
sure the directory has restrictive permissions.

     # mkdir /var/heimdal

The keys of all the principals are stored in the database.  If you
choose to, these can be encrypted with a master key.  You do not have to
remember this key (or password), but just to enter it once and it will
be stored in a file (`/var/heimdal/m-key').  If you want to have a
master key, run `kstash' to create this master key:

     # kstash
     Master key:
     Verifying password - Master key:

If you want to generate a random master key you can use the -random-key
to kstash. This will make sure you have a good key on which attackers
can't do a dictionary attack.

If you have a master key, make sure you make a backup of your master
key file; without it backups of the database are of no use.

To initialise the database use the `kadmin' program, with the `-l'
option (to enable local database mode). First issue a `init MY.REALM'
command. This will create the database and insert default principals
for that realm. You can have more than one realm in one database, so
`init' does not destroy any old database.

Before creating the database, `init' will ask you some questions about
maximum ticket lifetimes.

After creating the database you should probably add yourself to it. You
do this with the `add' command. It takes as argument the name of a
principal. The principal should contain a realm, so if you haven't set
up a default realm, you will need to explicitly include the realm.

     # kadmin -l
     kadmin> init MY.REALM
     Realm max ticket life [unlimited]:
     Realm max renewable ticket life [unlimited]:
     kadmin> add me
     Max ticket life [unlimited]:
     Max renewable life [unlimited]:
     Attributes []:
     Password:
     Verifying password - Password:

Now start the KDC and try getting a ticket.

     # kdc &
     # kinit me
     me@MY.REALMS's Password:
     # klist
     Credentials cache: /tmp/krb5cc_0
             Principal: me@MY.REALM
     
       Issued           Expires          Principal
     Aug 25 07:25:55  Aug 25 17:25:55  krbtgt/MY.REALM@MY.REALM

If you are curious you can use the `dump' command to list all the
entries in the database.  It should look something similar to the
following example (note that the entries here are truncated for
typographical reasons):

     kadmin> dump
     me@MY.REALM 1:0:1:0b01d3cb7c293b57:-:0:7:8aec316b9d1629e3baf8 ...
     kadmin/admin@MY.REALM 1:0:1:e5c8a2675b37a443:-:0:7:cb913ebf85 ...
     krbtgt/MY.REALM@MY.REALM 1:0:1:52b53b61c875ce16:-:0:7:c8943be ...
     kadmin/changepw@MY.REALM 1:0:1:f48c8af2b340e9fb:-:0:7:e3e6088 ...


File: heimdal.info,  Node: Modifying the database,  Next: keytabs,  Prev: Creating the database,  Up: Setting up a realm

Modifying the database
======================

All modifications of principals are done with with kadmin.

A principal have several attributes and lifetimes associated with it.

Principals are added, renamed, modified, and deleted with the kadmin
commands `add', `rename', `modify', `delete'.  Both interactive editing
and command switches can be used (use -help to list the available
options).

There are different kind of types for the fields in the database,
attributes, absolute time times and relative times.

Attributes
----------

When doing interactive editing, attributes are listed with `?'.

The attributes are given in a comma (`,') separated list.  Attributes
are removed from the list by prefixing them with `-'.

     kadmin> modify me
     Max ticket life [1 day]:
     Max renewable life [1 week]:
     Principal expiration time [never]:
     Password expiration time [never]:
     Attributes [disallow-renewable]: requires-pre-auth,-disallow-renewable
     kadmin> get me
                 Principal: me@MY.REALM
     [...]
                Attributes: requires-pre-auth

Absolute times
--------------

The format for absolute times are any of the following

     never
     now
     YYYY-mm-dd
     YYYY-mm-dd HH:MM:SS

Relative times
--------------

The format for relative times are any of the following combined

     N year
     M month
     O day
     P hour
     Q minute
     R second


File: heimdal.info,  Node: keytabs,  Next: Serving Kerberos 4/524/kaserver,  Prev: Modifying the database,  Up: Setting up a realm

keytabs
=======

To extract a service ticket from the database and put it in a keytab,
you need to first create the principal in the database with `ank'
(using the `--random-key' flag to get a random key) and then extract it
with `ext_keytab'.

     kadmin> add --random-key host/my.host.name
     Max ticket life [unlimited]:
     Max renewable life [unlimited]:
     Attributes []:
     kadmin> ext host/my.host.name
     kadmin> exit
     # ktutil list
     Version  Type             Principal
          1   des-cbc-md5      host/my.host.name@MY.REALM
          1   des-cbc-md4      host/my.host.name@MY.REALM
          1   des-cbc-crc      host/my.host.name@MY.REALM
          1   des3-cbc-sha1    host/my.host.name@MY.REALM


File: heimdal.info,  Node: Serving Kerberos 4/524/kaserver,  Next: Remote administration,  Prev: keytabs,  Up: Setting up a realm

Serving Kerberos 4/524/kaserver
===============================

Heimdal can be configured to support 524, Kerberos 4 or kaserver. All
these services turned off by default. Kerberos 4 support also depends
on if Kerberos 4 support being compiled in with Heimdal.

524
---

524 is a service that allows the KDC to convert Kerberos 5 tickets to
Kerberos 4 tickets for backward compatibility. See also Using 2b tokens
with AFS in *Note Things in search for a better place::.

524 can be turned on by adding this to the configuration file

     [kdc]
     	enable-524 = yes

Kerberos 4
----------

Kerberos 4 is the predecessor to to Kerberos 5. It only supports single
DES. You should only enable Kerberos 4 support if you have a need for
for compatibility with an installed base of Kerberos 4 clients/servers.

Kerberos 4 can be turned on by adding this to the configuration file

     [kdc]
     	enable-kerberos4 = yes

kaserver
--------

Kaserver is a Kerberos 4 that is used in AFS.  The protocol have some
extra features over plain Kerberos 4, but like Kerberos 4, only use
single DES.

You should only enable Kaserver support if you have a need for for
compatibility with an installed base of AFS machines.

Kaserver can be turned on by adding this to the configuration file

     [kdc]
     	enable-kaserver = yes


File: heimdal.info,  Node: Remote administration,  Next: Password changing,  Prev: Serving Kerberos 4/524/kaserver,  Up: Setting up a realm

Remote administration
=====================

The administration server, `kadmind', can be started by `inetd' (which
isn't recommended) or run as a normal daemon. If you want to start it
from `inetd' you should add a line similar to the one below to your
`/etc/inetd.conf'.

     kerberos-adm stream     tcp     nowait  root /usr/heimdal/libexec/kadmind kadmind

You might need to add `kerberos-adm' to your `/etc/services' as
`749/tcp'.

Access to the administration server is controlled by an ACL file,
(default `/var/heimdal/kadmind.acl'.) The lines in the access file,
have the following syntax:
     principal       [priv1,priv2,...]       [glob-pattern]

The matching is from top to bottom for matching principals (and if
given, glob-pattern).  When there is a match, the access rights of that
line are used.

The privileges you can assign to a principal are: `add',
`change-password' (or `cpw' for short), `delete', `get', `list', and
`modify', or the special privilege `all'. All of these roughly
corresponds to the different commands in `kadmin'.

If a GLOB-PATTERN is given on a line, it restricts the access rights for
the principal to only apply for the subjects that match the pattern.
The patterns are of the same type as those used in shell globbing, see
<none,,fnmatch(3)>.

In the example below `lha/admin' can change every principal in the
database. `jimmy/admin' can only modify principals that belong to the
realm `E.KTH.SE'. `mille/admin' is working at the help desk, so he
should only be able to change the passwords for single component
principals (ordinary users). He will not be able to change any `/admin'
principal.

     lha/admin@E.KTH.SE	all
     jimmy/admin@E.KTH.SE	all		*@E.KTH.SE
     jimmy/admin@E.KTH.SE	all		*/*@E.KTH.SE
     mille/admin@E.KTH.SE	change-password	*@E.KTH.SE


File: heimdal.info,  Node: Password changing,  Next: Testing clients and servers,  Prev: Remote administration,  Up: Setting up a realm

Password changing
=================

To allow users to change their passwords, you should run `kpasswdd'.
It is not run from `inetd'.

You might need to add `kpasswd' to your `/etc/services' as `464/udp'.

Password quality assurance
--------------------------

It is important that users have good passwords, both to make it harder
to guess them and to avoid off-line attacks (although
pre-authentication provides some defense against off-line attacks).  To
ensure that the users choose good passwords, you can enable password
quality controls in `kpasswdd' and `kadmind'.  The controls themselves
are done in a shared library or an external program that is used by
`kpasswdd'.  To configure in these controls, add lines similar to the
following to your `/etc/krb5.conf':

     [password_quality]
     	policies = external-check builtin:minimum-length module:policyname
     	external_program = /bin/false
     	policy_libraries = LIBRARY1.SO LIBRARY2.SO

In `[password_quality]policies' the module name is optional if the
policy name is unique in all modules (members of `policy_libraries').

The builtin polices are

   * external-check

     Executes the program specified by
     `[password_quality]external_program'.

     A number of key/value pairs is passed as input to the program, one
     per line, ending with the string `end'.  The key/value lines are of
     the form
          principal: PRINCIPAL
          new-password: PASSWORD
     where PASSWORD is the password to check for the previous PRINCIPAL.

     If the external application approves the password, it should return
     `APPROVED' on standard out and exit with exit code 0.  If it
     doesn't approve the password, a one line error message explaining
     the problem should be returned on standard error and the
     application should exit with exit code 0.  In case of a fatal
     error, the application should, if possible, print an error message
     on standard error and exit with a non-zero error code.

   * minimum-length

     The minimum length password quality check reads the configuration
     file stanza `[password_quality]min_length' and requires the
     password to be at least this length.

   * character-class

     The character-class password quality check reads the configuration
     file stanza `[password_quality]min_classes'. The policy requires
     the password to have characters from at least that many characters
     classes. Default value if not given is 3.

     The four diffrent characters classes are, uppercase, lowercase,
     number, special characters.


If you want to write you own shared object that checks password
policies, see the manual page `kadm5_pwcheck(3)'.

Code for a password quality checking function that uses the cracklib
library can be found in `lib/kadm5/sample_password_check.c' in the
source code distribution.  It requires the cracklib library built with
the patch available at
<ftp://ftp.pdc.kth.se/pub/krb/src/cracklib.patch>.

A sample policy external program is included in
`lib/kadm5/check-cracklib.pl'.

If no password quality checking function is configured, it is only
verified that it is at least six characters long.

The program `test_pw_quality', which is built in `lib/kadm5', but not
installed, can be used to check password policy settings.  It may be
convenient to set the environment variable `KRB5_CONFIG' to point to a
test version of `krb5.conf' while you're testing the
`[password_quality]' stanza that way.


File: heimdal.info,  Node: Testing clients and servers,  Next: Slave Servers,  Prev: Password changing,  Up: Setting up a realm

Testing clients and servers
===========================

Now you should be able to run all the clients and servers.  Refer to the
appropriate man pages for information on how to use them.


File: heimdal.info,  Node: Slave Servers,  Next: Incremental propagation,  Prev: Testing clients and servers,  Up: Setting up a realm

Slave servers, Incremental propagation, Testing clients and servers, Setting up a realm
=======================================================================================

It is desirable to have at least one backup (slave) server in case the
master server fails. It is possible to have any number of such slave
servers but more than three usually doesn't buy much more redundancy.

All Kerberos servers for a realm must have the same database so that
they present the same service to all the users.  The `hprop' program,
running on the master, will propagate the database to the slaves,
running `hpropd' processes.

Every slave needs a database directory, the master key (if it was used
for the database) and a keytab with the principal `hprop/HOSTNAME'.
Add the principal with the `ktutil' command and start `hpropd', as
follows:

     slave# ktutil get -p foo/admin hprop/`hostname`
     slave# mkdir /var/heimdal
     slave# hpropd

The master will use the principal `kadmin/hprop' to authenticate to the
slaves.  This principal should be added when running `kadmin -l init'
but if you do not have it in your database for whatever reason, please
add it with `kadmin -l add'.

Then run `hprop' on the master:

     master# hprop slave

This was just an hands-on example to make sure that everything was
working properly.  Doing it manually is of course the wrong way, and to
automate this you will want to start `hpropd' from `inetd' on the
slave(s) and regularly run `hprop' on the master to regularly propagate
the database.  Starting the propagation once an hour from `cron' is
probably a good idea.


File: heimdal.info,  Node: Incremental propagation,  Next: Salting,  Prev: Slave Servers,  Up: Setting up a realm

Incremental propagation
=======================

There is also a newer, and still somewhat experimental, mechanism for
doing incremental propagation in Heimdal.  Instead of sending the whole
database regularly, it sends the changes as they happen on the master to
the slaves.  The master keeps track of all the changes by assigning a
version number to every change to the database.  The slaves know which
was the latest version they saw and in this way it can be determined if
they are in sync or not.  A log of all the changes is kept on the
master, and when a slave is at an older version than the oldest one in
the log, the whole database has to be sent.

Protocol-wise, all the slaves connect to the master and as a greeting
tell it the latest version that they have (`IHAVE' message).  The
master then responds by sending all the changes between that version and
the current version at the master (a series of `FORYOU' messages) or
the whole database in a `TELLYOUEVERYTHING' message.  There is also a
keep-alive protocol that makes sure all slaves are up and running.

Configuring incremental propagation
-----------------------------------

The program that runs on the master is `ipropd-master' and all clients
run `ipropd-slave'.

Create the file `/var/heimdal/slaves' on the master containing all the
slaves that the database should be propagated to.  Each line contains
the full name of the principal (for example
`iprop/hemligare.foo.se@FOO.SE').

You should already have `iprop/tcp' defined as 2121, in your
`/etc/services'.  Otherwise, or if you need to use a different port for
some peculiar reason, you can use the `--port' option.  This is useful
when you have multiple realms to distribute from one server.

Then you need to create those principals that you added in the
configuration file.  Create one `iprop/hostname' for the master and for
every slave.

     master# /usr/heimdal/sbin/ktutil get iprop/`hostname`

The next step is to start the `ipropd-master' process on the master
server.  The `ipropd-master' listens on the UNIX domain socket
`/var/heimdal/signal' to know when changes have been made to the
database so they can be propagated to the slaves.  There is also a
safety feature of testing the version number regularly (every 30
seconds) to see if it has been modified by some means that do not raise
this signal.  Then, start `ipropd-slave' on all the slaves:

     master# /usr/heimdal/libexec/ipropd-master &
     slave#  /usr/heimdal/libexec/ipropd-slave master &


File: heimdal.info,  Node: Salting,  Next: Cross realm,  Prev: Incremental propagation,  Up: Setting up a realm

Salting
=======

Salting is used to make it harder to precalculate all possible keys.
Using a salt increases the search space to make it almost impossible to
precalculate all keys. Salting is the process of mixing a public string
(the salt) with the password, then sending it through an encryption
type specific string-to-key function that will output the fixed size
encryption key.

In Kerberos 5 the salt is determined by the encryption-type, except in
some special cases.

In `des' there is the Kerberos 4 salt (none at all) or the afs-salt
(using the cell (realm in AFS lingo)).

In `arcfour' (the encryption type that Microsoft Windows 2000 uses)
there is no salt. This is to be compatible with NTLM keys in Windows NT
4.

`[kadmin]default_keys' in `krb5.conf' controls what salting to use,

The syntax of `[kadmin]default_keys' is
`[etype:]salt-type[:salt-string]'. `etype' is the encryption type (des,
des3, arcfour), `salt-type' is the type of salt (pw-salt or afs3-salt),
and the salt-string is the string that will be used as salt (remember
that if the salt is appended/prepended, the empty salt "" is the same
thing as no salt at all).

Common types of salting include

   * `v4' (or `des:pw-salt:')

     The Kerberos 4 salting is using no salt at all. Reason there is
     colon at the end of the salt string is that it makes the salt the
     empty string (same as no salt).

   * `v5' (or `pw-salt')

     `pw-salt' uses the default salt for each encryption type is
     specified for. If the encryption type `etype' isn't given, all
     default encryption will be used.

   * `afs3-salt'

     `afs3-salt' is the salt that is used with Transarc kaserver. Its
     the cell name appended to the password.



File: heimdal.info,  Node: Cross realm,  Next: Transit policy,  Prev: Salting,  Up: Setting up a realm

Cross realm
===========

Suppose you reside in the realm `MY.REALM', how do you authenticate to
a server in `OTHER.REALM'? Having valid tickets in `MY.REALM' allows
you to communicate with Kerberised services in that realm. However, the
computer in the other realm does not have a secret key shared with the
Kerberos server in your realm.

It is possible to share keys between two realms that trust each other.
When a client program, such as `telnet' or `ssh', finds that the other
computer is in a different realm, it will try to get a ticket granting
ticket for that other realm, but from the local Kerberos server. With
that ticket granting ticket, it will then obtain service tickets from
the Kerberos server in the other realm.

For a two way trust between `MY.REALM' and `OTHER.REALM' add the
following principals to each realm. The principals should be
`krbtgt/OTHER.REALM@MY.REALM' and `krbtgt/MY.REALM@OTHER.REALM' in
`MY.REALM', and `krbtgt/MY.REALM@OTHER.REALM' and
`krbtgt/OTHER.REALM@MY.REALM'in `OTHER.REALM'.

In Kerberos 5 the trust can be configured to be one way. So that users
from `MY.REALM' can authenticate to services in `OTHER.REALM', but not
the opposite. In the example above, the `krbtgt/MY.REALM@OTHER.REALM'
then should be removed.

The two principals must have the same key, key version number, and the
same set of encryption types. Remember to transfer the two keys in a
safe manner.

     vr$ klist
     Credentials cache: FILE:/tmp/krb5cc_913.console
             Principal: lha@E.KTH.SE
     
       Issued           Expires          Principal
     May  3 13:55:52  May  3 23:55:54  krbtgt/E.KTH.SE@E.KTH.SE
     
     vr$ telnet -l lha hummel.it.su.se
     Trying 2001:6b0:5:1095:250:fcff:fe24:dbf...
     Connected to hummel.it.su.se.
     Escape character is '^]'.
     Waiting for encryption to be negotiated...
     [ Trying mutual KERBEROS5 (host/hummel.it.su.se@SU.SE)... ]
     [ Kerberos V5 accepts you as ``lha@E.KTH.SE'' ]
     Encryption negotiated.
     Last login: Sat May  3 14:11:47 from vr.l.nxs.se
     hummel$ exit
     
     vr$ klist
     Credentials cache: FILE:/tmp/krb5cc_913.console
             Principal: lha@E.KTH.SE
     
       Issued           Expires          Principal
     May  3 13:55:52  May  3 23:55:54  krbtgt/E.KTH.SE@E.KTH.SE
     May  3 13:55:56  May  3 23:55:54  krbtgt/SU.SE@E.KTH.SE
     May  3 14:10:54  May  3 23:55:54  host/hummel.it.su.se@SU.SE


File: heimdal.info,  Node: Transit policy,  Next: Setting up DNS,  Prev: Cross realm,  Up: Setting up a realm

Transit policy
==============

If you want to use cross realm authentication through an intermediate
realm, it must be explicitly allowed by either the KDCs or the server
receiving the request. This is done in `krb5.conf' in the `[capaths]'
section.

When the ticket transits through a realm to another realm, the
destination realm adds its peer to the "transited-realms" field in the
ticket. The field is unordered, since there is no way to know if know
if one of the transited-realms changed the order of the list.

The syntax for `[capaths]' section:

     [capaths]
             CLIENT-REALM = {
                     SERVER-REALM = PERMITTED-CROSS-REALMS ...
             }

The realm `STACKEN.KTH.SE' allows clients from `SU.SE' and `DSV.SU.SE'
to cross it. Since `STACKEN.KTH.SE' only have direct cross realm with
`KTH.SE', and `DSV.SU.SE' only have direct cross realm with `SU.SE'
they need to use both `SU.SE' and `KTH.SE' as transit realms.

     [capaths]
     	SU.SE = {
                         STACKEN.KTH.SE = KTH.SE
     	}
     	DSV.SU.SE = {
                         STACKEN.KTH.SE = SU.SE KTH.SE
     	}

The order of the `PERMITTED-CROSS-REALMS' is not important when doing
transit cross realm verification.

However the order is important when the `[capaths]' section is used to
figure out the intermediate realm to go to when doing multi-realm
transit. When figuring out the next realm, the first realm of the list
of `PERMITTED-CROSS-REALMS' is chosen. This is done in both the client
kerberos library and the KDC.


File: heimdal.info,  Node: Setting up DNS,  Next: Using LDAP to store the database,  Prev: Transit policy,  Up: Setting up a realm

Setting up DNS
==============

Using DNS to find KDC
---------------------

If there is information about where to find the KDC or kadmind for a
realm in the `krb5.conf' for a realm, that information will be
preferred, and DNS will not be queried.

Heimdal will try to use DNS to find the KDCs for a realm. First it will
try to find a `SRV' resource record (RR) for the realm. If no SRV RRs
are found, it will fall back to looking for an `A' RR for a machine
named kerberos.REALM, and then kerberos-1.REALM, etc

Adding this information to DNS makes the client have less configuration
(in the common case, no configuration) and allows the system
administrator to change the number of KDCs and on what machines they
are running without caring about clients.

The down side of using DNS that the client might be fooled to use the
wrong server if someone fakes DNS replies/data, but storing the IP
addresses of the KDC on all the clients makes it very hard to change
the infrastructure.

An example of the configuration for the realm `EXAMPLE.COM',


     $ORIGIN example.com.
     _kerberos._tcp          SRV     10 1 88 kerberos.example.com.
     _kerberos._udp          SRV     10 1 88 kerberos.example.com.
     _kerberos._tcp          SRV     10 1 88 kerberos-1.example.com.
     _kerberos._udp          SRV     10 1 88 kerberos-1.example.com.
     _kpasswd._udp           SRV     10 1 464 kerberos.example.com.
     _kerberos-adm._tcp	SRV	10 1 749 kerberos.example.com.

More information about DNS SRV resource records can be found in
RFC-2782 (A DNS RR for specifying the location of services (DNS SRV)).

Using DNS to map hostname to Kerberos realm
-------------------------------------------

Heimdal also supports a way to lookup a realm from a hostname. This to
minimize configuration needed on clients. Using this has the drawback
that clients can be redirected by an attacker to realms within the same
cross realm trust and made to believe they are talking to the right
server (since Kerberos authentication will succeed).

An example configuration that informs clients that for the realms
it.example.com and srv.example.com, they should use the realm
EXAMPLE.COM:


     $ORIGIN example.com.
     _kerberos.it		TXT     "EXAMPLE.COM"
     _kerberos.srv		TXT     "EXAMPLE.COM"


File: heimdal.info,  Node: Using LDAP to store the database,  Next: Providing Kerberos credentials to servers and programs,  Prev: Setting up DNS,  Up: Setting up a realm

Using LDAP to store the database
================================

This document describes how to install the LDAP backend for Heimdal.
Note that before attempting to configure such an installation, you
should be aware of the implications of storing private information
(such as users' keys) in a directory service primarily designed for
public information. Nonetheless, with a suitable authorization policy,
it is possible to set this up in a secure fashion. A knowledge of LDAP,
Kerberos, and C is necessary to install this backend. The HDB schema
was devised by Leif Johansson.

Requirements:

   * A current release of Heimdal, configured with
     `--with-openldap=/usr/local' (adjust according to where you have
     installed OpenLDAP).

     You can verify that you manage to configure LDAP support by running
     `kdc --builtin-hdb', and checking that `ldap:' is one entry in the
     list.

     Its also possible to configure the ldap backend as a shared module,
     see option -hdb-openldap-module to configure.

   * OpenLDAP 2.0.x. Configure OpenLDAP with `--enable-local' to enable
     the local transport. (A patch to support SASL EXTERNAL
     authentication is necessary in order to use OpenLDAP 2.1.x.)

   * Add the hdb schema to the LDAP server, its included in the
     source-tree in `lib/hdb/hdb.schema'. Example from slapd.conf:

          include /usr/local/etc/openldap/schema/hdb.schema

   * Configure the LDAP server ACLs to accept writes from clients over
     the local transport. For example:

          access to *
                  by dn.exact="uid=heimdal,dc=services,dc=example,dc=com" write
                  ...
          
          sasl-regexp "uidNumber=0\\\+gidNumber=.*,cn=peercred,cn=external,cn=auth"
          	"uid=heimdal,dc=services,dc=example,dc=com"

     The sasl-regexp is for mapping between the SASL/EXTERNAL and a
     user in a tree.  The user that the key is mapped to should be have
     a krb5Principal aux object with krb5PrincipalName set so that the
     "creator" and "modifier" is right in `kadmin'.

     Another option is to create an admins group and add the dn to that
     group.

     Since Heimdal talkes to the LDAP server over a UNIX domain socket,
     and uses external sasl authentication, its not possible to require
     security layer quality (ssf in cyrus-sasl lingo). So that
     requirement has to be turned off in OpenLDAP `slapd' configuration
     file `slapd.conf'.

          sasl-secprops minssf=0

   *  Start `slapd' with the local listener (as well as the default
     TCP/IP listener on port 389) as follows:

              slapd -h "ldapi:/// ldap:///"

     Note: These is a bug in `slapd' where it appears to corrupt the
     krb5Key binary attribute on shutdown. This may be related to our
     use of the V3 schema definition syntax instead of the old
     UMich-style, V2 syntax.

   * You should specify the distinguished name under which your
     principals will be stored in `krb5.conf':

          [kdc]
                  database = {
                          dbname = ldap:ou=KerberosPrincipals,dc=example,dc=com
                          mkey_file = /path/to/mkey
                  }

     `mkey_file' can be excluded if you feel that you trust your ldap
     directory to have the raw keys inside it.

   * Once you have built Heimdal and started the LDAP server, run kadmin
     (as usual) to initialize the database. Note that the instructions
     for stashing a master key are as per any Heimdal installation.

          kdc# kadmin -l
          kadmin> init EXAMPLE.COM
          Realm max ticket life [unlimited]:
          Realm max renewable ticket life [unlimited]:
          kadmin> ank lukeh
          Max ticket life [1 day]:
          Max renewable life [1 week]:
          Principal expiration time [never]:
          Password expiration time [never]:
          Attributes []:
          lukeh@EXAMPLE.COM's Password:
          Verifying password - lukeh@EXAMPLE.COM's Password:
          kadmin> exit

     Verify that the principal database has indeed been stored in the
     directory with the following command:

          kdc# ldapsearch -L -h localhost -D cn=manager \
           -w secret -b ou=KerberosPrincipals,dc=example,dc=com \
           'objectclass=krb5KDCEntry'

   * Now consider adding indexes to the database to speed up the
     access, at least theses should be added to slapd.conf.

          index	objectClass		eq
          index	cn			eq,sub,pres
          index	uid			eq,sub,pres
          index	displayName		eq,sub,pres
          index	krb5PrincipalName	eq


Troubleshooting guide
---------------------

<https://sec.miljovern.no/bin/view/Info/TroubleshootingGuide>

Using Samba LDAP password database
----------------------------------

Samba domain and the Kerberos realm can have diffrent names since
arcfour's string to key function principal/realm independent.  So now
will be your first and only chance name your Kerberos without needing
to deal with old configuration files.

First you should set up Samba and get that working with LDAP backend.

Now you can proceed as in *Note Using LDAP to store the database::,
Heimdal will pick up the Samba LDAP entries if they are in the same
search space as the Kerberos entries.


File: heimdal.info,  Node: Providing Kerberos credentials to servers and programs,  Prev: Using LDAP to store the database,  Up: Setting up a realm

Providing Kerberos credentials to servers and programs
======================================================

Some service require Kerberos credentials when they start to make
connections to other services or use them when they have started.

The easiest way to get ticket for the a service is to store the key in
a keytab. Both ktutil get and kadmin ext can be used to get a keytab.
ktutil get is better in that way it changes the key/password for the
user. This the problem with the ktutil. It ktutil is used for the same
service principal on several hosts, they keytab will only useful on the
last host. In that case, run the command on host and copy the keytab
around to all other hosts that needs it.

     host# ktutil -k /etc/krb5-service.keytab \
           get -p lha/admin@EXAMPLE.ORG service-principal@EXAMPLE.ORG
     lha/admin@EXAMPLE.ORG's Password:

To get a Kerberos credential file for the service, use kinit in the
-keytab mode, this will not ask for a password but rather that the key
from the keytab.

     service@host$ kinit --cache=/var/run/service_krb5_cache \
                    --keytab=/etc/krb5-service.keytab \
            service-principal@EXAMPLE.ORG

Long running services might need credentials longer then the expiration
time of the tickets. kinit can run in a mode that refreshes the tickets
before they expire. This is useful for services that write into AFS and
other distributed file systems using Kerberos. To run the long running
script, just append the program and arguments (if any) after the
principal. kinit will stop refreshing credentials and remove the
credentials when the script-to-start-service exits.

     service@host$ kinit --cache=/var/run/service_krb5_cache \
            --keytab=/etc/krb5-service.keytab \
            service-principal@EXAMPLE.ORG \
            script-to-start-service argument1 argument2


File: heimdal.info,  Node: Applications,  Next: Things in search for a better place,  Prev: Setting up a realm,  Up: Top

Applications
************

* Menu:

* Authentication modules::
* AFS::


File: heimdal.info,  Node: Authentication modules,  Next: AFS,  Prev: Applications,  Up: Applications

Authentication modules
======================

The problem of having different authentication mechanisms has been
recognised by several vendors, and several solutions has appeared. In
most cases these solutions involve some kind of shared modules that are
loaded at run-time.  Modules for some of these systems can be found in
`lib/auth'.  Presently there are modules for Digital's SIA, and IRIX'
`login' and `xdm' (in `lib/auth/afskauthlib').

* Menu:

* Digital SIA::
* IRIX::

