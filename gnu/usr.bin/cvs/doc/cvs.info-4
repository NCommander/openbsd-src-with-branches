This is Info file cvs.info, produced by Makeinfo-1.55 from the input
file ../../ccvs/doc/cvs.texinfo.

   Copyright (C) 1992, 1993 Signum Support AB Copyright (C) 1993, 1994
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
and this permission notice may be included in translations approved by
the Free Software Foundation instead of in the original English.


File: cvs.info,  Node: commit examples,  Prev: commit options,  Up: commit

commit examples
---------------

New major release number
........................

   When you make a major release of your product, you might want the
revision numbers to track your major release number.  You should
normally not care about the revision numbers, but this is a thing that
many people want to do, and it can be done without doing any harm.

   To bring all your files up to the RCS revision 3.0 (including those
that haven't changed), you might do:

     $ cvs commit -r 3.0

   Note that it is generally a bad idea to try to make the RCS revision
number equal to the current release number of your product.  You should
think of the revision number as an internal number that the CVS package
maintains, and that you generally never need to care much about.  Using
the `tag' and `rtag' commands you can give symbolic names to the
releases instead.  *Note tag:: and *Note rtag::.

   Note that the number you specify with `-r' must be larger than any
existing revision number.  That is, if revision 3.0 exists, you cannot
`cvs commit -r 1.3'.

Committing to a branch
......................

   You can commit to a branch revision (one that has an even number of
dots) with the `-r' option.  To create a branch revision, use the `-b'
option of the `rtag' or `tag' commands (*note tag::.  or *note
rtag::.).  Then, either `checkout' or `update' can be used to base your
sources on the newly created branch.  From that point on, all `commit'
changes made within these working sources will be automatically added
to a branch revision, thereby not disturbing main-line development in
any way.  For example, if you had to create a patch to the 1.2 version
of the product, even though the 2.0 version is already under
development, you might do:

     $ cvs rtag -b -r FCS1_2 FCS1_2_Patch product_module
     $ cvs checkout -r FCS1_2_Patch product_module
     $ cd product_module
     [[ hack away ]]
     $ cvs commit

This works automatically since the `-r' option is sticky.

Creating the branch after editing
.................................

   Say you have been working on some extremely experimental software,
based on whatever revision you happened to checkout last week.  If
others in your group would like to work on this software with you, but
without disturbing main-line development, you could commit your change
to a new branch.  Others can then checkout your experimental stuff and
utilize the full benefit of CVS conflict resolution.  The scenario might
look like:

     [[ hacked sources are present ]]
     $ cvs tag -b EXPR1
     $ cvs update -r EXPR1
     $ cvs commit

   The `update' command will make the `-r EXPR1' option sticky on all
files.  Note that your changes to the files will never be removed by the
`update' command.  The `commit' will automatically commit to the
correct branch, because the `-r' is sticky.  You could also do like
this:

     [[ hacked sources are present ]]
     $ cvs tag -b EXPR1
     $ cvs commit -r EXPR1

but then, only those files that were changed by you will have the `-r
EXPR1' sticky flag.  If you hack away, and commit without specifying
the `-r EXPR1' flag, some files may accidentally end up on the main
trunk.

   To work with you on the experimental change, others would simply do

     $ cvs checkout -r EXPR1 whatever_module


File: cvs.info,  Node: diff,  Next: export,  Prev: commit,  Up: Invoking CVS

diff--Run diffs between revisions
=================================

   * Synopsis: diff [-l] [rcsdiff_options] [[-r rev1 | -D date1] [-r
     rev2 |  -D date2]] [files...]

   * Requires: working directory, repository.

   * Changes: nothing.

   The `diff' command is used to compare different revisions of files.
The default action is to compare your working files with the revisions
they were based on, and report any differences that are found.

   If any file names are given, only those files are compared.  If any
directories are given, all files under them will be compared.

   The exit status will be 0 if no differences were found, 1 if some
differences were found, and 2 if any error occurred.

* Menu:

* diff options::                diff options
* diff examples::               diff examples


File: cvs.info,  Node: diff options,  Next: diff examples,  Up: diff

diff options
------------

   These standard options are supported by `diff' (*note Common
options::., for a complete description of them):

`-D DATE'
     Use the most recent revision no later than DATE.  See `-r' for how
     this affects the comparison.

     CVS can be configured to pass the `-D' option through to `rcsdiff'
     (which in turn passes it on to `diff'.  GNU diff uses `-D' as a
     way to put `cpp'-style `#define' statements around the output
     differences.  There is no way short of testing to figure out how
     CVS was configured.  In the default configuration CVS will use the
     `-D DATE' option.

`-k KFLAG'
     Process RCS keywords according to KFLAG.  See co(1).

`-l'
     Local; run only in current working directory.

`-R'
     Examine directories recursively.  This option is on by default.

`-r TAG'
     Compare with revision TAG.  Zero, one or two `-r' options can be
     present.  With no `-r' option, the working file will be compared
     with the revision it was based on.  With one `-r', that revision
     will be compared to your current working file.  With two `-r'
     options those two revisions will be compared (and your working
     file will not affect the outcome in any way).

     One or both `-r' options can be replaced by a `-D DATE' option,
     described above.

   Any other options that are found are passed through to `rcsdiff',
which in turn passes them to `diff'.  The exact meaning of the options
depends on which `diff' you are using.  The long options introduced in
GNU diff 2.0 are not yet supported in CVS.  See the documentation for
your `diff' to see which options are supported.


File: cvs.info,  Node: diff examples,  Prev: diff options,  Up: diff

diff examples
-------------

   The following line produces a Unidiff (`-u' flag) between revision
1.14 and 1.19 of `backend.c'.  Due to the `-kk' flag no keywords are
substituted, so differences that only depend on keyword substitution
are ignored.

     $ cvs diff -kk -u -r 1.14 -r 1.19 backend.c

   Suppose the experimental branch EXPR1 was based on a set of files
tagged RELEASE_1_0.  To see what has happened on that branch, the
following can be used:

     $ cvs diff -r RELEASE_1_0 -r EXPR1

   A command like this can be used to produce a context diff between
two releases:

     $ cvs diff -c -r RELEASE_1_0 -r RELEASE_1_1 > diffs

   If you are maintaining ChangeLogs, a command like the following just
before you commit your changes may help you write the ChangeLog entry.
All local modifications that have not yet been committed will be
printed.

     $ cvs diff -u | less


File: cvs.info,  Node: export,  Next: history,  Prev: diff,  Up: Invoking CVS

export--Export sources from CVS, similar to checkout
====================================================

   * Synopsis: export [-flNn] [-r rev|-D date] [-k subst] [-d dir]
     module...

   * Requires: repository.

   * Changes: current directory.

   This command is a variant of `checkout'; use it when you want a copy
of the source for module without the CVS administrative directories.
For example, you might use `export' to prepare source for shipment
off-site.  This command requires that you specify a date or tag (with
`-D' or `-r'), so that you can count on reproducing the source you ship
to others.

   One often would like to use `-kv' with `cvs export'.  This causes
any RCS keywords to be expanded such that an import done at some other
site will not lose the keyword revision information.  But be aware that
doesn't handle an export containing binary files correctly.  Also be
aware that after having used `-kv', one can no longer use the `ident'
command (which is part of the RCS suite--see ident(1)) which looks for
RCS keyword strings.  If you want to be able to use `ident' you must not
use `-kv'.

* Menu:

* export options::              export options


File: cvs.info,  Node: export options,  Up: export

export options
--------------

   These standard options are supported by `export' (*note Common
options::., for a complete description of them):

`-D DATE'
     Use the most recent revision no later than DATE.

`-f'
     If no matching revision is found, retrieve the most recent
     revision (instead of ignoring the file).

`-l'
     Local; run only in current working directory.

`-n'
     Do not run any checkout program.

`-R'
     Export directories recursively.  This is on by default.

`-r TAG'
     Use revision TAG.

   In addition, these options (that are common to `checkout' and
`export') are also supported:

`-d DIR'
     Create a directory called DIR for the working files, instead of
     using the module name.  Unless you also use `-N', the paths
     created under DIR will be as short as possible.

`-k SUBST'
     Set keyword expansion mode (*note Substitution modes::.).

`-N'
     Only useful together with `-d DIR'.  With this option, CVS will
     not shorten module paths in your working directory.  (Normally,
     CVS shortens paths as much as possible when you specify an
     explicit target directory.)


File: cvs.info,  Node: history,  Next: import,  Prev: export,  Up: Invoking CVS

history--Show status of files and users
=======================================

   * Synopsis:     history [-report] [-flags] [-options args] [files...]

   * Requires: the file `$CVSROOT/CVSROOT/history'

   * Changes: nothing.

   CVS can keep a history file that tracks each use of the `checkout',
`commit', `rtag', `update', and `release' commands.  You can use
`history' to display this information in various formats.

   Logging must be enabled by creating the file
`$CVSROOT/CVSROOT/history'.

   *Warning:* `history' uses `-f', `-l', `-n', and `-p' in ways that
conflict with the normal use inside CVS (*note Common options::.).

* Menu:

* history options::             history options


File: cvs.info,  Node: history options,  Up: history

history options
---------------

   Several options (shown above as `-report')  control  what kind of
report is generated:

`-c'
     Report on each time commit was used (i.e., each time the
     repository was modified).

`-e'
     Everything (all record types); equivalent to specifying
     `-xMACFROGWUT'.

`-m MODULE'
     Report on a particular module.  (You can meaningfully use `-m'
     more than once on the command line.)

`-o'
     Report on checked-out modules.

`-T'
     Report on all tags.

`-x TYPE'
     Extract a particular set of record types TYPE from the CVS
     history.  The types are indicated by single letters, which you may
     specify in combination.

     Certain commands have a single record type:

    `F'
          release

    `O'
          checkout

    `T'
          rtag

     One of four record types may result from an update:

    `C'
          A merge was necessary but collisions were detected (requiring
          manual merging).

    `G'
          A merge was necessary and it succeeded.

    `U'
          A working file was copied from the repository.

    `W'
          The working copy of a file was deleted during update (because
          it was gone from the repository).

     One of three record types results from commit:

    `A'
          A file was added for the first time.

    `M'
          A file was modified.

    `R'
          A file was removed.

   The options shown as `-flags' constrain or expand the report without
requiring option arguments:

`-a'
     Show data for all users (the default is to show data only for the
     user executing `history').

`-l'
     Show last modification only.

`-w'
     Show only the records for modifications done from the same working
     directory where `history' is executing.

   The options shown as `-options ARGS' constrain the report based on
an argument:

`-b STR'
     Show data back to a record containing  the  string STR  in  either
     the module name, the file name, or the repository path.

`-D DATE'
     Show data since DATE.  This is slightly different from the normal
     use of `-D DATE', which selects the newest revision older than
     DATE.

`-p REPOSITORY'
     Show data for a particular source repository  (you can specify
     several `-p' options on the same command line).

`-r REV'
     Show records referring to revisions since the revision or tag
     named REV appears in individual RCS files.  Each RCS file is
     searched for the revision or tag.

`-t TAG'
     Show records since tag TAG was last added to the the history file.
     This differs from the `-r' flag above in that it reads only the
     history file, not the RCS files, and is much faster.

`-u NAME'
     Show records for user NAME.


File: cvs.info,  Node: import,  Next: log,  Prev: history,  Up: Invoking CVS

import--Import sources into CVS, using vendor branches
======================================================

   * Synopsis: import [-options] repository vendortag releasetag...

   * Requires: Repository, source distribution directory.

   * Changes: repository.

   Use `import' to incorporate an entire source distribution from an
outside source (e.g., a source vendor) into your source repository
directory.  You can use this command both for initial creation of a
repository, and for wholesale updates to the module from the outside
source.  *Note Tracking sources::, for a discussion on this subject.

   The REPOSITORY argument gives a directory name (or a path to a
directory) under the CVS root directory for repositories; if the
directory did not exist, import creates it.

   When you use import for updates to source that has been modified in
your source repository (since a prior import), it will notify you of
any files that conflict in the two branches of development; use
`checkout -j' to reconcile the differences, as import instructs you to
do.

   If CVS decides a file should be ignored (*note cvsignore::.), it
does not import it and prints `I ' followed by the filename

   If the file `$CVSROOT/CVSROOT/cvswrappers' exists, any file whose
names match the specifications in that file will be treated as packages
and the appropriate filtering will be performed on the file/directory
before being imported, *Note Wrappers::.

   The outside source is saved in a first-level RCS branch, by default
1.1.1.  Updates are leaves of this branch; for example, files from the
first imported collection of source will be revision 1.1.1.1, then
files from the first imported update will be revision 1.1.1.2, and so
on.

   At least three arguments are required.  REPOSITORY is needed to
identify the collection of source.  VENDORTAG is a tag for the entire
branch (e.g., for 1.1.1).  You must also specify at least one
RELEASETAG to identify the files at the leaves created each time you
execute `import'.

* Menu:

* import options::              import options
* import examples::             import examples


File: cvs.info,  Node: import options,  Next: import examples,  Up: import

import options
--------------

   This standard option is supported by `import' (*note Common
options::., for a complete description):

`-m MESSAGE'
     Use MESSAGE as log information, instead of invoking an editor.

   There are three additional special options.

`-b BRANCH'
     Specify a first-level branch other than 1.1.1.  Unless the `-b
     BRANCH' flag is given, revisions will *always* be made to the
     branch 1.1.1--even if a VENDORTAG that matches another branch is
     given!  What happens in that case, is that the tag will be reset
     to 1.1.1.  Warning: This behavior might change in the future.

`-k SUBST'
     Indicate the RCS keyword expansion mode desired.  This setting
     will apply to all files created during the import, but not to any
     files that previously existed in the repository.  See *Note
     Substitution modes:: for a list of valid `-k' settings.

`-I NAME'
     Specify file names that should be ignored during import.  You can
     use this option repeatedly.  To avoid ignoring any files at all
     (even those ignored by default), specify `-I !'.

     NAME can be a file name pattern of the same type that you can
     specify in the `.cvsignore' file.  *Note cvsignore::.

`-W SPEC'
     Specify file names that should be filtered during import.  You can
     use this option repeatedly.

     SPEC can be a file name pattern of the same type that you can
     specify in the `.cvswrappers' file. *Note Wrappers::.


File: cvs.info,  Node: import examples,  Prev: import options,  Up: import

import examples
---------------

   *Note Tracking sources::, and *Note From files::.


File: cvs.info,  Node: log,  Next: rdiff,  Prev: import,  Up: Invoking CVS

log--Print out 'rlog' information for files
===========================================

   * Synopsis: log [-l] rlog-options [files...]

   * Requires: repository, working directory.

   * Changes: nothing.

   * Synonym: rlog

   Display log information for files.  `log' calls the RCS utility
`rlog', which prints all available information about the RCS history
file.  This includes the location of the RCS file, the "head" revision
(the latest revision on the trunk), all symbolic names (tags) and some
other things.  For each revision, the revision number, the author, the
number of lines added/deleted and the log message are printed.  All
times are displayed in Coordinated Universal Time (UTC).  (Other parts
of CVS print times in the local timezone).

* Menu:

* log options::                 log options
* log examples::                log examples


File: cvs.info,  Node: log options,  Next: log examples,  Up: log

log options
-----------

   Only one option is interpreted by CVS and not passed on to `rlog':

`-l'
     Local; run only in current working directory.  (Default is to run
     recursively).

   By default, `rlog' prints all information that is available.  All
other options (including those that normally behave differently) are
passed through to `rlog' and restrict the output.  See rlog(1) for a
complete description of options.  This incomplete list (which is a
slightly edited extract from rlog(1)) lists all options that are useful
in conjunction with CVS.

   *Please note:*  There can be no space between the option and its
argument, since `rlog' parses its options in a different way than CVS.

`-b'
     Print information about the revisions on the default branch,
     normally the highest branch on the trunk.

`-dDATES'
     Print information about revisions with a checkin date/time in the
     range given by the semicolon-separated list of dates.  The
     following table explains the available range formats:

    `D1<D2'
    `D2>D1'
          Select the revisions that were deposited between D1 and D2
          inclusive.

    `<D'
    `D>'
          Select all revisions dated D or earlier.

    `D<'
    `>D'
          Select all revisions dated D or later.

    `D'
          Select the single, latest revision dated D or earlier.

     The date/time strings D, D1, and D2 are in the free format
     explained in co(1).  Quoting is normally necessary, especially for
     < and >.  Note that the separator is a semicolon (;).

`-h'
     Print only the RCS pathname, working pathname, head, default
     branch, access list, locks, symbolic names, and suffix.

`-N'
     Do not print the list of tags for this file.  This option can be
     very useful when your site uses a lot of tags, so rather than
     "more"'ing over 3 pages of tag information, the log information is
     presented without tags at all.

`-R'
     Print only the name of the RCS history file.

`-rREVISIONS'
     Print information about revisions given in the comma-separated
     list REVISIONS of revisions and ranges.  The following table
     explains the available range formats:

    `REV1:REV2'
          Revisions REV1 to REV2 (which must be on the same branch).

    `:REV'
          Revisions from the beginning of the branch up to and
          including REV.

    `REV:'
          Revisions starting with REV to the end of the branch
          containing REV.

    `BRANCH'
          An argument that is a branch means all revisions on that
          branch.  You can unfortunately not specify a symbolic branch
          here.  You must specify the numeric branch number.  *Note
          Magic branch numbers::, for an explanation.

    `BRANCH1:BRANCH2'
          A range of branches means all revisions on the branches in
          that range.

    `BRANCH.'
          The latest revision in BRANCH.

     A bare `-r' with no revisions means the latest revision on the
     default branch, normally the trunk.

`-sSTATES'
     Print information about revisions whose state attributes match one
     of the states given in the comma-separated list STATES.

`-t'
     Print the same as `-h', plus the descriptive text.

`-wLOGINS'
     Print information about revisions checked in by users with login
     names appearing in the comma-separated list LOGINS.  If LOGINS is
     omitted, the user's login is assumed.

   `rlog' prints the intersection of the revisions selected with the
options `-d', `-l', `-s', and `-w', intersected with the union of the
revisions selected by `-b' and `-r'.


File: cvs.info,  Node: log examples,  Prev: log options,  Up: log

log examples
------------

   Contributed examples are gratefully accepted.


File: cvs.info,  Node: rdiff,  Next: release,  Prev: log,  Up: Invoking CVS

rdiff--'patch' format diffs between releases
============================================

   * rdiff [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...

   * Requires: repository.

   * Changes: nothing.

   * Synonym: patch

   Builds a Larry Wall format patch(1) file between two releases, that
can be fed directly into the patch program to bring an old release
up-to-date with the new release.  (This is one of the few CVS commands
that operates directly from the repository, and doesn't require a prior
checkout.) The diff output is sent to the standard output device.

   You can specify (using the standard `-r' and `-D' options) any
combination of one or two revisions or dates.  If only one revision or
date is specified, the patch file reflects differences between that
revision or date and the current head revisions in the RCS file.

   Note that if the software release affected is contained in more than
one directory, then it may be necessary to specify the `-p' option to
the patch command when patching the old sources, so that patch is able
to find the files that are located in other directories.

* Menu:

* rdiff options::               rdiff options
* rdiff examples::              rdiff examples


File: cvs.info,  Node: rdiff options,  Next: rdiff examples,  Up: rdiff

rdiff options
-------------

   These standard options are supported by `rdiff' (*note Common
options::., for a complete description of them):

`-D DATE'
     Use the most recent revision no later than DATE.

`-f'
     If no matching revision is found, retrieve the most recent
     revision (instead of ignoring the file).

`-l'
     Local; don't descend subdirectories.

`-r TAG'
     Use revision TAG.

   In addition to the above, these options are available:

`-c'
     Use the context diff format.  This is the default format.

`-s'
     Create a summary change report instead of a patch.  The summary
     includes information about files that were changed or added
     between the releases.  It is sent to the standard output device.
     This is useful for finding out, for example, which files have
     changed between two dates or revisions.

`-t'
     A diff of the top two revisions is sent to the standard output
     device.  This is most useful for seeing what the last change to a
     file was.

`-u'
     Use the unidiff format for the context diffs.  This option is not
     available if your diff does not support the unidiff format.
     Remember that old versions of the `patch' program can't handle the
     unidiff format, so if you plan to post this patch to the net you
     should probably not use `-u'.

`-V VN'
     Expand RCS keywords according to the rules current in RCS version
     VN (the expansion format changed with RCS version 5).


File: cvs.info,  Node: rdiff examples,  Prev: rdiff options,  Up: rdiff

rdiff examples
--------------

   Suppose you receive mail from foo@bar.com asking for an update from
release 1.2 to 1.4 of the tc compiler.  You have no such patches on
hand, but with CVS that can easily be fixed with a command such as this:

     $ cvs rdiff -c -r FOO1_2 -r FOO1_4 tc | \
     $$ Mail -s 'The patches you asked for' foo@bar.com

   Suppose you have made release 1.3, and forked a branch called
`R_1_3fix' for bugfixes.  `R_1_3_1' corresponds to release 1.3.1, which
was made some time ago.  Now, you want to see how much development has
been done on the branch.  This command can be used:

     $ cvs patch -s -r R_1_3_1 -r R_1_3fix module-name
     cvs rdiff: Diffing module-name
     File ChangeLog,v changed from revision 1.52.2.5 to 1.52.2.6
     File foo.c,v changed from revision 1.52.2.3 to 1.52.2.4
     File bar.h,v changed from revision 1.29.2.1 to 1.2


File: cvs.info,  Node: release,  Next: rtag,  Prev: rdiff,  Up: Invoking CVS

release--Indicate that a Module is no longer in use
===================================================

   * release [-d] modules...

   * Requires: Working directory.

   * Changes: Working directory, history log.

   This command is meant to safely cancel the effect of `cvs checkout'.
Since CVS doesn't lock files, it isn't strictly necessary to use this
command.  You can always simply delete your working directory, if you
like; but you risk losing changes you may have forgotten, and you leave
no trace in the CVS history file (*note history file::.) that you've
abandoned your checkout.

   Use `cvs release' to avoid these problems.  This command checks that
no uncommitted changes are present; that you are executing it from
immediately above a CVS working directory; and that the repository
recorded for your files is the same as the repository defined in the
module database.

   If all these conditions are true, `cvs release' leaves a record of
its execution (attesting to your intentionally abandoning your
checkout) in the CVS history log.

* Menu:

* release options::             release options
* release output::              release options
* release examples::            release examples


File: cvs.info,  Node: release options,  Next: release output,  Up: release

release options
---------------

   The `release' command supports one command option:

`-d'
     Delete your working copy of the file if the release succeeds.  If
     this flag is not given your files will remain in your working
     directory.

     *Warning:*  The `release' command uses `rm -r `module'' to delete
     your file.  This has the very serious side-effect that any
     directory that you have created inside your checked-out sources,
     and not added to the repository (using the `add' command; *note
     add::.) will be silently deleted--even if it is non-empty!


File: cvs.info,  Node: release output,  Next: release examples,  Prev: release options,  Up: release

release output
--------------

   Before `release' releases your sources it will print a one-line
message for any file that is not up-to-date.

   *Warning:*  Any new directories that you have created, but not added
to the CVS directory hierarchy with the `add' command (*note add::.)
will be silently ignored (and deleted, if `-d' is specified), even if
they contain files.

`U FILE'
     There exists a newer revision of this file in the repository, and
     you have not modified your local copy of the file.

`A FILE'
     The file has been added to your private copy of the sources, but
     has not yet been committed to the repository.  If you delete your
     copy of the sources this file will be lost.

`R FILE'
     The file has been removed from your private copy of the sources,
     but has not yet been removed from the repository, since you have
     not yet committed the removal.  *Note commit::.

`M FILE'
     The file is modified in your working directory.  There might also
     be a newer revision inside the repository.

`? FILE'
     FILE is in your working directory, but does not correspond to
     anything in the source repository, and is not in the list of files
     for CVS to ignore (see the description of the `-I' option, and
     *note cvsignore::.).  If you remove your working sources, this
     file will be lost.

     Note that no warning message like this is printed for spurious
     directories that CVS encounters.  The directory, and all its
     contents, are silently ignored.


File: cvs.info,  Node: release examples,  Prev: release output,  Up: release

release examples
----------------

   Release the module, and delete your local working copy of the files.

     $ cd ..         # You must stand immediately above the
                     # sources when you issue `cvs release'.
     $ cvs release -d tc
     You have [0] altered files in this repository.
     Are you sure you want to release (and delete) module `tc': y
     $


File: cvs.info,  Node: rtag,  Next: status,  Prev: release,  Up: Invoking CVS

rtag--Add a tag to the RCS file
===============================

   * rtag [-falnR] [-b] [-d] [-r tag | -Ddate] symbolic_tag modules...

   * Requires: repository.

   * Changes: repository.

   * Synonym: rfreeze

   You can use this command to assign symbolic tags to particular,
explicitly specified source revisions in the repository.  `rtag' works
directly on the repository contents (and requires no prior checkout).
Use `tag' instead (*note tag::.), to base the selection of revisions on
the contents of your working directory.

   If you attempt to use a tag name that already exists, CVS will
complain and not overwrite that tag.  Use the `-F' option to force the
new tag value.

* Menu:

* rtag options::                rtag options


File: cvs.info,  Node: rtag options,  Up: rtag

rtag options
------------

   These standard options are supported by `rtag' (*note Common
options::., for a complete description of them):

`-D DATE'
     Tag the most recent revision no later than DATE.

`-f'
     Only useful with the `-D DATE' or `-r TAG' flags.  If no matching
     revision is found, use the most recent revision (instead of
     ignoring the file).

`-F'
     Overwrite an existing tag of the same name on a different
     revision.  This option is new in CVS 1.4.  The old behavior is
     matched by `cvs tag -F'.

`-l'
     Local; run only in current working directory.

`-n'
     Do not run any tag program that was specified with the `-t' flag
     inside the `modules' file.  (*note modules::.).

`-R'
     Commit directories recursively.  This is on by default.

`-r TAG'
     Only tag those files that contain TAG.  This can be used to rename
     a tag: tag only the files identified by the old tag, then delete
     the old tag, leaving the new tag on exactly the same files as the
     old tag.

   In addition to the above common options, these options are available:

`-a'
     Use the `-a' option to have `rtag' look in the `Attic' (*note
     Removing files::.) for removed files that contain the specified
     tag.  The tag is removed from these files, which makes it
     convenient to re-use a symbolic tag as development continues (and
     files get removed from the up-coming distribution).

`-b'
     Make the tag a branch tag.  *Note Branches::.

`-d'
     Delete the tag instead of creating it.

     In general, tags (often the symbolic names of software
     distributions) should not be removed, but the `-d' option is
     available as a means to remove completely obsolete symbolic names
     if necessary (as might be the case for an Alpha release, or if you
     mistagged a module).


File: cvs.info,  Node: status,  Next: tag,  Prev: rtag,  Up: Invoking CVS

status--Status info on the revisions
====================================

   * status [-lR] [-v] [files...]

   * Requires: working directory, repository.

   * Changes: nothing.

   Display a brief report on the current status of files with respect
to the source repository, including any sticky tags, dates, or `-k'
options.

   You can also use this command to determine the potential impact of a
`cvs update' on your working source directory--but remember that things
might change in the repository before you run `update'.

* Menu:

* status options::              status options


File: cvs.info,  Node: status options,  Up: status

status options
--------------

   These standard options are supported by `status' (*note Common
options::., for a complete description of them):

`-l'
     Local; run only in current working directory.

`-R'
     Commit directories recursively.  This is on by default.

   There is one additional option:

`-v'
     Verbose.  In addition to the information normally displayed, print
     all symbolic tags, together with the numerical value of the
     revision or branch they refer to.


File: cvs.info,  Node: tag,  Next: update,  Prev: status,  Up: Invoking CVS

tag--Add a symbolic tag to checked out version of RCS file
==========================================================

   * tag [-lR] [-b] [-d] symbolic_tag [files...]

   * Requires: working directory, repository.

   * Changes: repository.

   * Synonym: freeze

   Use this command to assign symbolic tags to the nearest repository
versions to your working sources.  The tags are applied immediately to
the repository, as with `rtag', but the versions are supplied
implicitly by the CVS records of your working files' history rather than
applied explicitly.

   One use for tags is to record a snapshot of the current sources when
the software freeze date of a project arrives.  As bugs are fixed after
the freeze date, only those changed sources that are to be part of the
release need be re-tagged.

   The symbolic tags are meant to permanently record which revisions of
which files were used in creating a software distribution.  The
`checkout' and `update' commands allow you to extract an exact copy of
a tagged release at any time in the future, regardless of whether files
have been changed, added, or removed since the release was tagged.

   This command can also be used to delete a symbolic tag, or to create
a branch.  See the options section below.

   If you attempt to use a tag name that already exists, CVS will
complain and not overwrite that tag.  Use the `-F' option to force the
new tag value.

* Menu:

* tag options::                 tag options


File: cvs.info,  Node: tag options,  Up: tag

tag options
-----------

   These standard options are supported by `tag' (*note Common
options::., for a complete description of them):

`-F'
     Overwrite an existing tag of the same name on a different
     revision.  This option is new in CVS 1.4.  The old behavior is
     matched by `cvs tag -F'.

`-l'
     Local; run only in current working directory.

`-R'
     Commit directories recursively.  This is on by default.

   Two special options are available:

`-b'
     The -b option makes the tag a branch tag (*note Branches::.),
     allowing concurrent, isolated development.  This is most useful
     for creating a patch to a previously released software
     distribution.

`-d'
     Delete a tag.

     If you use `cvs tag -d symbolic_tag', the symbolic tag you specify
     is deleted instead of being added.  Warning: Be very certain of
     your ground before you delete a tag; doing this permanently
     discards some historical information, which may later turn out to
     be valuable.


File: cvs.info,  Node: update,  Prev: tag,  Up: Invoking CVS

update--Bring work tree in sync with repository
===============================================

   * update [-AdflPpR] [-d] [-r tag|-D date] files...

   * Requires: repository, working directory.

   * Changes: working directory.

   After you've run checkout to create your private copy of source from
the common repository, other developers will continue changing the
central source.  From time to time, when it is convenient in your
development process, you can use the `update' command from within your
working directory to reconcile your work with any revisions applied to
the source repository since your last checkout or update.

* Menu:

* update options::              update options
* update output::               update output
* update examples::             update examples


File: cvs.info,  Node: update options,  Next: update output,  Up: update

update options
--------------

   These standard options are available with `update' (*note Common
options::., for a complete description of them):

`-D date'
     Use the most recent revision no later than DATE.  This option is
     sticky, and implies `-P'.  See *Note Sticky tags::, for more
     information on sticky tags/dates.

`-f'
     Only useful with the `-D DATE' or `-r TAG' flags.  If no matching
     revision is found, retrieve the most recent revision (instead of
     ignoring the file).

`-k KFLAG'
     Process RCS keywords according to KFLAG.  See co(1).  This option
     is sticky; future updates of this file in this working directory
     will use the same KFLAG.  The `status' command can be viewed to
     see the sticky options.  *Note status::.

`-l'
     Local; run only in current working directory.  *Note Recursive
     behavior::.

`-P'
     Prune empty directories.

`-p'
     Pipe files to the standard output.

`-R'
     Operate recursively.  This is on by default.  *Note Recursive
     behavior::.

`-r tag'
     Retrieve revision TAG.  This option is sticky, and implies `-P'.
     See *Note Sticky tags::, for more information on sticky tags/dates.

   These special options are also available with `update'.

`-A'
     Reset any sticky tags, dates, or `-k' options.  See *Note Sticky
     tags::, for more information on sticky tags/dates.

`-d'
     Create any directories that exist in the repository if they're
     missing from the working directory.  Normally, `update' acts only
     on directories and files that were already enrolled in your
     working directory.

     This is useful for updating directories that were created in the
     repository since the initial checkout; but it has an unfortunate
     side effect.  If you deliberately avoided certain directories in
     the repository when you created your working directory (either
     through use of a module name or by listing explicitly the files
     and directories you wanted on the command line), then updating
     with `-d' will create those directories, which may not be what you
     want.

`-I NAME'
     Ignore files whose names match NAME (in your working directory)
     during the update.  You can specify `-I' more than once on the
     command line to specify several files to ignore.  Use `-I !' to
     avoid ignoring any files at all.  *Note cvsignore::, for other
     ways to make CVS ignore some files.

`-WSPEC'
     Specify file names that should be filtered during update.  You can
     use this option repeatedly.

     SPEC can be a file name pattern of the same type that you can
     specify in the `.cvswrappers' file. *Note Wrappers::.

`-jREVISION'
     With two `-j' options, merge changes from the revision specified
     with the first `-j' option to the revision specified with the
     second `j' option, into the working directory.

     With one `-j' option, merge changes from the ancestor revision to
     the revision specified with the `-j' option, into the working
     directory.  The ancestor revision is the common ancestor of the
     revision which the working directory is based on, and the revision
     specified in the `-j' option.

     In addition, each -j option can contain an optional date
     specification which, when used with branches, can limit the chosen
     revision to one within a specific date.  An optional date is
     specified by adding a colon (:) to the tag:
     `-jSYMBOLIC_TAG:DATE_SPECIFIER'.

     *Note Merging::.


File: cvs.info,  Node: update output,  Next: update examples,  Prev: update options,  Up: update

update output
-------------

   `update' keeps you informed of its progress by printing a line for
each file, preceded by one character indicating the status of the file:

`U FILE'
     The file was brought up to date with respect to the repository.
     This is done for any file that exists in the repository but not in
     your source, and for files that you haven't changed but are not
     the most recent versions available in the repository.

`A FILE'
     The file has been added to your private copy of the sources, and
     will be added to the source repository when you run `commit' on
     the file.  This is a reminder to you that the file needs to be
     committed.

`R FILE'
     The file has been removed from your private copy of the sources,
     and will be removed from the source repository when you run
     `commit' on the file.  This is a reminder to you that the file
     needs to be committed.

`M FILE'
     The file is modified in  your  working  directory.

     `M' can indicate one of two states for a file you're working on:
     either there were no modifications to the same file in the
     repository, so that your file remains as you last saw it; or there
     were modifications in the repository as well as in your copy, but
     they were merged successfully, without conflict, in your working
     directory.

     CVS will print some messages if it merges your work, and a backup
     copy of your working file (as it looked before you ran `update')
     will be made.  The exact name of that file is printed while
     `update' runs.

`C FILE'
     A conflict was detected while trying to merge your changes to FILE
     with changes from the source repository.  FILE (the copy in your
     working directory) is now the output of the rcsmerge(1) command on
     the two revisions; an unmodified copy of your file is also in your
     working directory, with the name `.#FILE.REVISION' where REVISION
     is the RCS revision that your modified file started from.  (Note
     that some systems automatically purge files that begin with `.#'
     if they have not been accessed for a few days.  If you intend to
     keep a copy of your original file, it is a very good idea to rename
     it.)

`? FILE'
     FILE is in your working directory, but does not correspond to
     anything in the source repository, and is not in the list of files
     for CVS to ignore (see the description of the `-I' option, and
     *note cvsignore::.).

     Note that no warning message like this is printed for spurious
     directories that CVS encounters.  The directory, and all its
     contents, are silently ignored.


File: cvs.info,  Node: update examples,  Prev: update output,  Up: update

update examples
---------------

   The following line will display all files which are not up-to-date
without actually change anything in your working directory.  It can be
used to check what has been going on with the project.

     $ cvs -n -q update


File: cvs.info,  Node: Administrative files,  Next: Environment variables,  Prev: Invoking CVS,  Up: Top

Reference manual for the Administrative files
*********************************************

   Inside the repository, in the directory `$CVSROOT/CVSROOT', there
are a number of supportive files for CVS.  You can use CVS in a limited
fashion without any of them, but if they are set up properly they can
help make life easier.

   The most important of these files is the `modules' file, which
defines the modules inside the repository.

* Menu:

* modules::                     Defining modules
* Wrappers::                    Treat directories as files
* commit files::                The commit support files
* commitinfo::                  Pre-commit checking
* editinfo::                    Specifying how log messages are created
* loginfo::                     Where should log messages be sent?
* rcsinfo::                     Templates for the log messages
* cvsignore::                   Ignoring files via cvsignore
* history file::                History information
* Setting up::                  Setting up the repository
* Variables::                   Various variables are expanded


File: cvs.info,  Node: modules,  Next: Wrappers,  Up: Administrative files

The modules file
================

   The `modules' file records your definitions of names for collections
of source code.  CVS will use these definitions if you use CVS to
update the modules file (use normal commands like `add', `commit', etc).

   The `modules' file may contain blank lines and comments (lines
beginning with `#') as well as module definitions.  Long lines can be
continued on the next line by specifying a backslash (`\') as the last
character on the line.

   A module definition is a single line of the `modules' file, in
either of two formats.  In both cases, MNAME represents the symbolic
module name, and the remainder of the line is its definition.

`MNAME -a ALIASES...'
     This represents the simplest way of defining a module MNAME.  The
     `-a' flags the definition as a simple alias: CVS will treat any
     use of MNAME (as a command argument) as if the list of names
     ALIASES had been specified instead.  ALIASES may contain either
     other module names or paths.  When you use paths in aliases,
     `checkout' creates all intermediate directories in the working
     directory, just as if the path had been specified explicitly in
     the CVS arguments.

`MNAME [ options ] DIR [ FILES... ] [ &MODULE... ]'
     In the simplest case, this form of module definition reduces to
     `MNAME DIR'.  This defines all the files in directory DIR as
     module mname.  DIR is a relative path (from `$CVSROOT') to a
     directory of source in the source repository.  In this case, on
     checkout, a single directory called MNAME is created as a working
     directory; no intermediate directory levels are used by default,
     even if DIR was a path involving several directory levels.

     By explicitly specifying files in the module definition after DIR,
     you can select particular files from directory DIR.  The sample
     definition for `modules' is an example of a module defined with a
     single file from a particular directory.  Here is another example:

          m4test  unsupported/gnu/m4 foreach.m4 forloop.m4

     With this definition, executing `cvs checkout m4test' will create
     a single working directory `m4test' containing the two files
     listed, which both come from a common directory several levels deep
     in the CVS source repository.

     A module definition can refer to other modules by including
     `&MODULE' in its definition.  `checkout' creates a subdirectory
     for each such module, in your working directory.

    `-d NAME'
          Name the working directory something other than the module
          name.

    `-e PROG'
          Specify a program PROG to run whenever files in a module are
          exported.  PROG runs with a single argument, the module name.

    `-i PROG'
          Specify a program PROG to run whenever files in a module are
          committed.  PROG runs with a single argument, the full
          pathname of the affected directory in a source repository.
          The `commitinfo', `loginfo', and `editinfo' files provide
          other ways to call a program on commit.

    `-o PROG'
          Specify a program PROG to run whenever files in a module are
          checked out.  PROG runs with a single argument, the module
          name.

    `-s STATUS'
          Assign a status to the module.  When the module file is
          printed with `cvs checkout -s' the modules are sorted
          according to primarily module status, and secondarily
          according to the module name.  This option has no other
          meaning.  You can use this option for several things besides
          status: for instance, list the person that is responsible for
          this module.

    `-t PROG'
          Specify a program PROG to run whenever files in a module are
          tagged with `rtag'.  PROG runs with two arguments: the module
          name and the symbolic tag specified to `rtag'.  There is no
          way to specify a program to run when `tag' is executed.

    `-u PROG'
          Specify a program PROG to run whenever `cvs update' is
          executed from the top-level directory of the checked-out
          module.  PROG runs with a single argument, the full path to
          the source repository for this module.

