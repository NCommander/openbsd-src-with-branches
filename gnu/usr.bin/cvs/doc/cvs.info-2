This is Info file cvs.info, produced by Makeinfo-1.55 from the input
file ./cvs.texinfo.

   Copyright (C) 1992, 1993 Signum Support AB Copyright (C) 1993, 1994
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
and this permission notice may be included in translations approved by
the Free Software Foundation instead of in the original English.


File: cvs.info,  Node: Branches motivation,  Next: Creating a branch,  Prev: Tags,  Up: Branches

What branches are good for
==========================

   Suppose that release 1.0 of tc has been made.  You are continuing to
develop tc, planning to create release 1.1 in a couple of months.
After a while your customers start to complain about a fatal bug.  You
check out release 1.0 (*note Tags::.) and find the bug (which turns out
to have a trivial fix).  However, the current revision of the sources
are in a state of flux and are not expected to be stable for at least
another month.  There is no way to make a bugfix release based on the
newest sources.

   The thing to do in a situation like this is to create a "branch" on
the revision trees for all the files that make up release 1.0 of tc.
You can then make modifications to the branch without disturbing the
main trunk.  When the modifications are finished you can select to
either incorporate them on the main trunk, or leave them on the branch.


File: cvs.info,  Node: Creating a branch,  Next: Sticky tags,  Prev: Branches motivation,  Up: Branches

Creating a branch
=================

   The `rtag' command can be used to create a branch.  The `rtag'
command is much like `tag', but it does not require that you have a
working copy of the module.  *Note rtag::.  (You can also use the `tag'
command; *note tag::.).

     $ cvs rtag -b -r release-1-0 release-1-0-patches tc

   The `-b' flag makes `rtag' create a branch (rather than just a
symbolic revision name).  `-r release-1-0' says that this branch should
be rooted at the node (in the revision tree) that corresponds to the tag
`release-1-0'.  Note that the numeric revision number that matches
`release-1-0' will probably be different from file to file.  The name
of the new branch is `release-1-0-patches', and the module affected is
`tc'.

   To fix the problem in release 1.0, you need a working copy of the
branch you just created.

     $ cvs checkout -r release-1-0-patches tc
     $ cvs status -v driver.c backend.c
     ===================================================================
     File: driver.c          Status: Up-to-date
     
         Version:            1.7     Sat Dec  5 18:25:54 1992
         RCS Version:        1.7     /usr/local/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         release-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-1-0-patches             (branch: 1.7.2)
             release-1-0                     (revision: 1.7)
     
     ===================================================================
     File: backend.c         Status: Up-to-date
     
         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /usr/local/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         release-1-0-patches (branch: 1.4.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-1-0-patches             (branch: 1.4.2)
             release-1-0                     (revision: 1.4)
             release-0-4                     (revision: 1.4)

   As the output from the `status' command shows the branch number is
created by adding a digit at the tail of the revision number it is
based on.  (If `release-1-0' corresponds to revision 1.4, the branch's
revision number will be 1.4.2.  For obscure reasons CVS always gives
branches even numbers, starting at 2.  *Note Revision numbers::).


File: cvs.info,  Node: Sticky tags,  Prev: Creating a branch,  Up: Branches

Sticky tags
===========

   The `-r release-1-0-patches' flag that was given to `checkout' is
"sticky", that is, it will apply to subsequent commands in this
directory.  If you commit any modifications, they are committed on the
branch.  You can later merge the modifications into the main trunk.
*Note Merging::.

     $ vi driver.c   # Fix the bugs
     $ cvs commit -m "Fixed initialization bug" driver.c
     Checking in driver.c;
     /usr/local/cvsroot/yoyodyne/tc/driver.c,v  <--  driver.c
     new revision: 1.7.2.1; previous revision: 1.7
     done
     $ cvs status -v driver.c
     ===================================================================
     File: driver.c          Status: Up-to-date
     
         Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
         RCS Version:        1.7.2.1 /usr/local/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         release-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-1-0-patches             (branch: 1.7.2)
             release-1-0                     (revision: 1.7)

   The sticky tags will remain on your working files until you delete
them with `cvs update -A'.  *Note update::.

   Sticky tags are not just for branches.  If you check out a certain
revision (such as 1.4) it will also become sticky.  Subsequent `cvs
update' will not retrieve the latest revision until you reset the tag
with `cvs update -A'.

   See the descriptions in Appendix A for more information about sticky
tags.  Dates and some other options can also be sticky.  Again, see
Appendix A for details.


File: cvs.info,  Node: Merging,  Next: Recursive behavior,  Prev: Branches,  Up: Top

Merging
*******

   You can include the changes made between any two revisions into your
working copy, by "merging".  You can then commit that revision, and
thus effectively copy the changes onto another branch.

* Menu:

* Merging a branch::            Merging an entire branch
* Merging two revisions::       Merging differences between two revisions


File: cvs.info,  Node: Merging a branch,  Next: Merging two revisions,  Up: Merging

Merging an entire branch
========================

   You can merge changes made on a branch into your working copy by
giving the `-j BRANCH' flag to the `update' command.  With one `-j
BRANCH' option it merges the changes made between the point where the
branch forked and newest revision on that branch (into your working
copy).

   The `-j' stands for "join".  In previous versions of CVS there was a
special command, `cvs join', that was used to merge changes between
branches.

   Consider this revision tree:

     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !      <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !
                     !
                     !   +---------+    +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                         +---------+    +---------+    +---------+

The branch 1.2.2 has been given the tag (symbolic name) `R1fix'.  The
following example assumes that the module `mod' contains only one file,
`m.c'.

     $ cvs checkout mod               # Retrieve the latest revision, 1.5
     
     $ cvs update -j R1fix m.c        # Merge all changes made on the branch,
                                      # i.e. the changes between revision 1.2
                                      # and 1.2.2.3, into your working copy
                                      # of the file.
     
     $ cvs commit -m "Included R1fix" # Create revision 1.6.

   A conflict can result from a merge operation.  If that happens, you
should resolve it before committing the new revision.  *Note Conflicts
example::.

   The `checkout' command also supports the `-j BRANCH' flag.  The same
effect as above could be achieved with this:

     $ cvs checkout -j R1fix mod
     $ cvs commit -m "Included R1fix"


File: cvs.info,  Node: Merging two revisions,  Prev: Merging a branch,  Up: Merging

Merging differences between any two revisions
=============================================

   With two `-j REVISION' flags, the `update' (and `checkout') command
can merge the differences between any two revisions into your working
file.

     $ cvs update -j 1.5 -j 1.3 backend.c

will *remove* all changes made between revision 1.3 and 1.5.  Note the
order of the revisions!

   If you try to use this option with the `checkout' command, remember
that the numeric revisions will probably be very different between the
various files that make up a module.  You almost always use symbolic
tags rather than revision numbers with the `checkout' command.


File: cvs.info,  Node: Recursive behavior,  Next: Adding files,  Prev: Merging,  Up: Top

Recursive behavior
******************

   Almost all of the subcommands of CVS work recursively when you
specify a directory as an argument.  For instance, consider this
directory structure:

           `$HOME'
             |
             +--tc
             |   |
                 +--CVS
                 |      (internal CVS files)
                 +--Makefile
                 +--backend.c
                 +--driver.c
                 +--frontend.c
                 +--parser.c
                 +--man
                 |    |
                 |    +--CVS
                 |    |  (internal CVS files)
                 |    +--tc.1
                 |
                 +--testing
                      |
                      +--CVS
                      |  (internal CVS files)
                      +--testpgm.t
                      +--test2.t

If `tc' is the current working directory, the following is true:

   * `cvs update testing' is equivalent to `cvs update
     testing/testpgm.t testing/test2.t'

   * `cvs update testing man' updates all files in the subdirectories

   * `cvs update .' or just `cvs update' updates all files in the `tc'
     module

   If no arguments are given to `update' it will update all files in
the current working directory and all its subdirectories.  In other
words, `.' is a default argument to `update'.  This is also true for
most of the CVS subcommands, not only the `update' command.

   The recursive behavior of the CVS subcommands can be turned off with
the `-l' option.

     $ cvs update -l         # Don't update files in subdirectories


File: cvs.info,  Node: Adding files,  Next: Removing files,  Prev: Recursive behavior,  Up: Top

Adding files to a module
************************

   To add a new file to a module, follow these steps.

   * You must have a working copy of the module.  *Note Getting the
     source::.

   * Create the new file inside your working copy of the module.

   * Use `cvs add FILENAME' to tell CVS that you want to version
     control the file.

   * Use `cvs commit FILENAME' to actually check in the file into the
     repository.  Other developers cannot see the file until you
     perform this step.

   * If the file contains binary data it might be necessary to change
     the default keyword substitution.  *Note Keyword substitution::.
     *Note admin examples::.

   You can also use the `add' command to add a new directory inside a
module.

   Unlike most other commands, the `add' command is not recursive.  You
cannot even type `cvs add foo/bar'!  Instead, you have to

     $ cd foo
     $ cvs add bar

   *Note add::, for a more complete description of the `add' command.


File: cvs.info,  Node: Removing files,  Next: Tracking sources,  Prev: Adding files,  Up: Top

Removing files from a module
****************************

   Modules change.  New files are added, and old files disappear.
Still, you want to be able to retrieve an exact copy of old releases of
the module.

   Here is what you can do to remove a file from a module, but remain
able to retrieve old revisions:

   * Make sure that you have not made any uncommitted modifications to
     the file.  *Note Viewing differences::, for one way to do that.
     You can also use the `status' or `update' command.  If you remove
     the file without committing your changes, you will of course not
     be able to retrieve the file as it was immediately before you
     deleted it.

   * Remove the file from your working copy of the module.  You can for
     instance use `rm'.

   * Use `cvs remove FILENAME' to tell CVS that you really want to
     delete the file.

   * Use `cvs commit FILENAME' to actually perform the removal of the
     file from the repository.

   What happens when you commit the removal of the file is that inside
the source repository, it is moved into a subdirectory called `Attic'.
cVS normally doesn't look in that directory when you run e.g.
`checkout'.  However, if you are retrieving a certain revision via e.g.
`cvs checkout -r SOME-TAG', it will look at the files inside the
`Attic' and include any files that contain the specified tag.


File: cvs.info,  Node: Tracking sources,  Next: Moving files,  Prev: Removing files,  Up: Top

Tracking third-party sources
****************************

   If you modify a program to better fit your site, you probably want
to include your modifications when the next release of the program
arrives.  CVS can help you with this task.

   In the terminology used in CVS, the supplier of the program is
called a "vendor".  The unmodified distribution from the vendor is
checked in on its own branch, the "vendor branch".  CVS reserves branch
1.1.1 for this use.

   When you modify the source and commit it, your revision will end up
on the main trunk.  When a new release is made by the vendor, you
commit it on the vendor branch and copy the modifications onto the main
trunk.

   Use the `import' command to create and update the vendor branch.
After a successful `import' the vendor branch is made the `head'
revision, so anyone that checks out a copy of the file gets that
revision.  When a local modification is committed it is placed on the
main trunk, and made the `head' revision.

* Menu:

* First import::                Importing a module for the first time
* Update imports::              Updating a module with the import command


File: cvs.info,  Node: First import,  Next: Update imports,  Up: Tracking sources

Importing a module for the first time
=====================================

   Use the `import' command to check in the sources for the first time.
When you use the `import' command to track third-party sources, the
"vendor tag" and "release tags" are useful.  The "vendor tag" is a
symbolic name for the branch (which is always 1.1.1, unless you use the
`-b BRANCH' flag--*Note import options::).  The "release tags" are
symbolic names for a particular release, such as `FSF_0_04'.

   Suppose you use `wdiff' (a variant of `diff' that ignores changes
that only involve whitespace), and are going to make private
modifications that you want to be able to use even when new releases
are made in the future.  You start by importing the source to your
repository:

     $ tar xfz wdiff-0.04.tar.gz
     $ cd wdiff-0.04
     $ cvs import -m "Import of FSF v. 0.04" fsf/wdiff FSF WDIFF_0_04

   The vendor tag is named `FSF' in the above example, and the only
release tag assigned is `WDIFF_0_04'.


File: cvs.info,  Node: Update imports,  Prev: First import,  Up: Tracking sources

Updating a module with the import command
=========================================

   When a new release of the source arrives, you import it into the
repository with the same `import' command that you used to set up the
repository in the first place.  The only difference is that you specify
a different release tag this time.

     $ tar xfz wdiff-0.05.tar.gz
     $ cd wdiff-0.05
     $ cvs import -m "Import of FSF v. 0.05" fsf/wdiff FSF WDIFF_0_05

   For files that have not been modified locally, the newly created
revision becomes the head revision.  If you have made local changes,
`import' will warn you that you must merge the changes into the main
trunk, and tell you to use `checkout -j' to do so.

     $ cvs checkout -jFSF:yesterday -jFSF wdiff

The above command will check out the latest revision of `wdiff',
merging the changes made on the vendor branch `FSF' since yesterday
into the working copy.  If any conflicts arise during the merge they
should be resolved in the normal way (*note Conflicts example::.).
Then, the modified files may be committed.

   CVS assumes that you do not import more than one release of a
product per day. If you do, you can always use something like this
instead:

     $ cvs checkout -jWDIFF_0_04 -jWDIFF_0_05 wdiff

In this case, the two above commands are equivalent.


File: cvs.info,  Node: Moving files,  Next: Moving directories,  Prev: Tracking sources,  Up: Top

Moving and renaming files
*************************

   Moving files to a different directory or renaming them is not
difficult, but some of the ways in which this works may be non-obvious.
(Moving or renaming a directory is even harder.  *Note Moving
directories::).

   The examples below assume that the file OLD is renamed to NEW.

* Menu:

* Outside::                     The normal way to Rename
* Inside::                      A tricky, alternative way
* Rename by copying::           Another tricky, alternative way


File: cvs.info,  Node: Outside,  Next: Inside,  Up: Moving files

The Normal way to Rename
========================

   The normal way to move a file is to copy OLD to NEW, and then issue
the normal CVS commands to remove OLD from the repository, and add NEW
to it.  (Both OLD and NEW could contain relative paths, for example
`foo/bar.c').

     $ mv OLD NEW
     $ cvs remove OLD
     $ cvs add NEW
     $ cvs commit -m "Renamed OLD to NEW" OLD NEW

   This is the simplest way to move a file, it is not error-prone, and
it preserves the history of what was done.  Note that to access the
history of the file you must specify the old or the new name, depending
on what portion of the history you are accessing.  For example, `cvs
log OLD' will give the log up until the time of the rename.

   When NEW is committed its revision numbers will start at 1.0 again,
so if that bothers you, use the `-r rev' option to commit (*note commit
options::.)


File: cvs.info,  Node: Inside,  Next: Rename by copying,  Prev: Outside,  Up: Moving files

Moving the history file
=======================

   This method is more dangerous, since it involves moving files inside
the repository.  Read this entire section before trying it out!

     $ cd $CVSROOT/MODULE
     $ mv OLD,v NEW,v

Advantages:

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * Old releases of the module cannot easily be fetched from the
     repository.  (The file will show up as NEW even in revisions from
     the time before it was renamed).

   * There is no log information of when the file was renamed.

   * Nasty things might happen if someone accesses the history file
     while you are moving it.  Make sure no one else runs any of the CVS
     commands while you move it.


File: cvs.info,  Node: Rename by copying,  Prev: Inside,  Up: Moving files

Copying the history file
========================

   This way also involves direct modifications to the repository.  It
is safe, but not without drawbacks.

     # Copy the RCS file inside the repository
     $ cd $CVSROOT/MODULE
     $ cp OLD,v NEW,v
     # Remove the old file
     $ cd ~/MODULE
     $ rm OLD
     $ cvs remove OLD
     $ cvs commit OLD
     # Remove all tags from NEW
     $ cvs update NEW
     $ cvs log NEW             # Remember the tag names
     $ cvs tag -d TAG1
     $ cvs tag -d TAG2
     ...

   By removing the tags you will be able to check out old revisions of
the module.

Advantages:

   * Checking out old revisions works correctly, as long as you use
     `-rTAG' and not `-DDATE' to retrieve the revisions.

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * You cannot easily see the history of the file across the rename.

   * Unless you use the `-r rev' (*note commit options::.) flag when
     NEW is committed its revision numbers will start at 1.0 again.


File: cvs.info,  Node: Moving directories,  Next: Keyword substitution,  Prev: Moving files,  Up: Top

Moving and renaming directories
*******************************

   If you want to be able to retrieve old versions of the module, you
must move each file in the directory with the CVS commands.  *Note
Outside::.  The old, empty directory will remain inside the repository,
but it will not appear in your workspace when you check out the module
in the future.

   If you really want to rename or delete a directory, you can do it
like this:

  1. Inform everyone who has a copy of the module that the directory
     will be renamed.  They should commit all their changes, and remove
     their working copies of the module, before you take the steps
     below.

  2. Rename the directory inside the repository.

          $ cd $CVSROOT/MODULE
          $ mv OLD-DIR NEW-DIR

  3. Fix the CVS administrative files, if necessary (for instance if
     you renamed an entire module).

  4. Tell everyone that they can check out the module and continue
     working.


   If someone had a working copy of the module the CVS commands will
cease to work for him, until he removes the directory that disappeared
inside the repository.

   It is almost always better to move the files in the directory
instead of moving the directory.  If you move the directory you are
unlikely to be able to retrieve old releases correctly, since they
probably depend on the name of the directories.


File: cvs.info,  Node: Keyword substitution,  Next: Revision management,  Prev: Moving directories,  Up: Top

Keyword substitution
********************

   As long as you edit source files inside your working copy of a
module you can always find out the state of your files via `cvs status'
and `cvs log'.  But as soon as you export the files from your
development environment it becomes harder to identify which revisions
they are.

   RCS uses a mechanism known as "keyword substitution" (or "keyword
expansion") to help identifying the files.  Embedded strings of the form
`$KEYWORD$' and `$KEYWORD:...$' in a file are replaced with strings of
the form `$KEYWORD:VALUE$' whenever you obtain a new revision of the
file.

* Menu:

* Keyword list::                RCS Keywords
* Using keywords::              Using keywords
* Avoiding substitution::       Avoiding substitution
* Substitution modes::          Substitution modes
* Log keyword::                 Problems with the $Log$ keyword.


File: cvs.info,  Node: Keyword list,  Next: Using keywords,  Up: Keyword substitution

RCS Keywords
============

   This is a list of the keywords that RCS currently (in release
5.6.0.1) supports:

`$Author$'
     The login name of the user who checked in the revision.

`$Date$'
     The date and time (UTC) the revision was checked in.

`$Header$'
     A standard header containing the full pathname of the RCS file,
     the revision number, the date (UTC), the author, the state, and
     the locker (if locked).  Files will normally never be locked when
     you use CVS.

`$Id$'
     Same as `$Header$', except that the RCS filename is without a path.

`$Locker$'
     The login name of the user who locked the revision (empty if not
     locked, and thus almost always useless when you are using CVS).

`$Log$'
     The log message supplied during commit, preceded by a header
     containing the RCS filename, the revision number, the author, and
     the date (UTC).  Existing log messages are *not* replaced.
     Instead, the new log message is inserted after `$Log:...$'.  Each
     new line is prefixed with a "comment leader" which RCS guesses
     from the file name extension.  It can be changed with `cvs admin
     -c'.  *Note admin options::.  This keyword is useful for
     accumulating a complete change log in a source file, but for
     several reasons it can be problematic.  *Note Log keyword::.

`$RCSfile$'
     The name of the RCS file without a path.

`$Revision$'
     The revision number assigned to the revision.

`$Source$'
     The full pathname of the RCS file.

`$State$'
     The state assigned to the revision.  States can be assigned with
     `cvs admin -s'--*Note admin options::.


File: cvs.info,  Node: Using keywords,  Next: Avoiding substitution,  Prev: Keyword list,  Up: Keyword substitution

Using keywords
==============

   To include a keyword string you simply include the relevant text
string, such as `$Id$', inside the file, and commit the file.  CVS will
automatically expand the string as part of the commit operation.

   It is common to embed `$Id$' string in the C source code.  This
example shows the first few lines of a typical file, after keyword
substitution has been performed:

     static char *rcsid="$Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $";
     /* The following lines will prevent `gcc' version 2.X
        from issuing an "unused variable" warning. */
     #if __GNUC__ == 2
     #define USE(var) static void * use_##var = (&use_##var, (void *) &var)
     USE (rcsid);
     #endif

   Even though a clever optimizing compiler could remove the unused
variable `rcsid', most compilers tend to include the string in the
binary.  Some compilers have a `#pragma' directive to include literal
text in the binary.

   The `ident' command (which is part of the RCS package) can be used
to extract keywords and their values from a file.  This can be handy
for text files, but it is even more useful for extracting keywords from
binary files.

     $ ident samp.c
     samp.c:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $
     $ gcc samp.c
     $ ident a.out
     a.out:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $

   SCCS is another popular revision control system.  It has a command,
`what', which is very similar to `ident' and used for the same purpose.
Many sites without RCS have SCCS.  Since `what' looks for the
character sequence `@(#)' it is easy to include keywords that are
detected by either command.  Simply prefix the RCS keyword with the
magic SCCS phrase, like this:

     static char *id="@(#) $Id: ab.c,v 1.5 1993/10/19 14:57:32 ceder Exp $";


File: cvs.info,  Node: Avoiding substitution,  Next: Substitution modes,  Prev: Using keywords,  Up: Keyword substitution

Avoiding substitution
=====================

   Keyword substitution has its disadvantages.  Sometimes you might
want the literal text string `$Author$' to appear inside a file without
RCS interpreting it as a keyword and expanding it into something like
`$Author: ceder $'.

   There is unfortunately no way to selectively turn off keyword
substitution.  You can use `-ko' (*note Substitution modes::.) to turn
off keyword substitution entirely.  (If you put binaries under version
control you are strongly encouraged to use that option, for obvious
reasons).

   In many cases you can avoid using RCS keywords in the source, even
though they appear in the final product.  For example, the source for
this manual contains `$@asis{}Author$' whenever the text `$Author$'
should appear.  In `nroff' and `troff' you can embed the null-character
`\&' inside the keyword for a similar effect.


File: cvs.info,  Node: Substitution modes,  Next: Log keyword,  Prev: Avoiding substitution,  Up: Keyword substitution

Substitution modes
==================

   You can control how RCS expands keywords through the use of the `-k'
option (*note Common options::.).  The `-k' option is available with the
`add', `checkout', `diff' and `update' commands.

   Five different modes are available.  They are:

`-kkv'
     Generate keyword strings using the default form, e.g.  `$Revision:
     5.7 $' for the `Revision' keyword.

`-kkvl'
     Like `-kkv', except that a locker's name is always inserted if the
     given revision is currently locked.  This option is normally not
     useful when CVS is used.

`-kk'
     Generate only keyword names in keyword strings; omit their values.
     For example, for the `Revision' keyword, generate the string
     `$Revision$' instead of `$Revision: 5.7 $'.  This option is useful
     to ignore differences due to keyword substitution when comparing
     different revisions of a file.

`-ko'
     Generate the old keyword string, present in the working file just
     before it was checked in.  For example, for the `Revision'
     keyword, generate the string `$Revision: 1.1 $' instead of
     `$Revision: 5.7 $' if that is how the string appeared when the
     file was checked in.  This can be useful for binary file formats
     that cannot tolerate any changes to substrings that happen to take
     the form of keyword strings.

`-kv'
     Generate only keyword values for keyword strings.  For example,
     for the `Revision' keyword, generate the string `5.7' instead of
     `$Revision: 5.7 $'.  This can help generate files in programming
     languages where it is hard to strip keyword delimiters like
     `$Revision: $' from a string.  However, further keyword
     substitution cannot be performed once the keyword names are
     removed, so this option should be used with care.

     This option is always use by `cvs export'--*note export::..


File: cvs.info,  Node: Log keyword,  Prev: Substitution modes,  Up: Keyword substitution

Problems with the $Log$ keyword.
================================

   The `$Log$' keyword is somewhat controversial.  As long as you are
working on your development system the information is easily accessible
even if you do not use the `$Log$' keyword--just do a `cvs log'.  Once
you export the file the history information might be useless anyhow.

   A more serious concern is that RCS is not good at handling `$Log$'
entries when a branch is merged onto the main trunk.  Conflicts often
result from the merging operation.

   People also tend to "fix" the log entries in the file (correcting
spelling mistakes and maybe even factual errors).  If that is done the
information from `cvs log' will not be consistent with the information
inside the file.  This may or may not be a problem in real life.

   It has been suggested that the `$Log$' keyword should be inserted
*last* in the file, and not in the files header, if it is to be used at
all.  That way the long list of change messages will not interfere with
everyday source file browsing.


File: cvs.info,  Node: Revision management,  Next: Invoking CVS,  Prev: Keyword substitution,  Up: Top

Revision management
*******************

   If you have read this far, you probably have a pretty good grasp on
what CVS can do for you.  This chapter talks a little about things that
you still have to decide.

   If you are doing development on your own using CVS you could
probably skip this chapter.  The questions this chapter takes up become
more important when more than one person is working in a repository.

* Menu:

* When to commit::              Some discussion on the subject


File: cvs.info,  Node: When to commit,  Up: Revision management

When to commit?
===============

   Your group should decide which policy to use regarding commits.
Several policies are possible, and as your experience with CVS grows
you will probably find out what works for you.

   If you commit files too quickly you might commit files that do not
even compile.  If your partner updates his working sources to include
your buggy file, he will be unable to compile the code.  On the other
hand, other persons will not be able to benefit from the improvements
you make to the code if you commit very seldom, and conflicts will
probably be more common.

   It is common to only commit files after making sure that they can be
compiled.  Some sites require that the files pass a test suite.
Policies like this can be enforced using the commitinfo file (*note
commitinfo::.), but you should think twice before you enforce such a
convention.  By making the development environment too controlled it
might become too regimented and thus counter-productive to the real
goal, which is to get software written.


File: cvs.info,  Node: Invoking CVS,  Next: Administrative files,  Prev: Revision management,  Up: Top

Reference manual for CVS commands
*********************************

   This appendix describes every subcommand of CVS in detail.  It also
describes how to invoke CVS.

* Menu:

* Structure::                   Overall structure of CVS commands
* ~/.cvsrc::                    Default options with the ~/.csvrc file
* Global options::              Options you give to the left of cvs_command
* Common options::              Options you give to the right of cvs_command
* add::                         Add a new file/directory to the repository
* admin::                       Administration front end for rcs
* checkout::                    Checkout sources for editing
* commit::                      Check files into the repository
* diff::                        Run diffs between revisions
* export::                      Export sources from CVS, similar to checkout
* history::                     Show status of files and users
* import::                      Import sources into CVS, using vendor branches
* log::                         Print out 'rlog' information for files
* rdiff::                       'patch' format diffs between releases
* release::                     Indicate that a Module is no longer in use
* remove::                      Remove an entry from the repository
* rtag::                        Add a tag to a module
* status::                      Status info on the revisions
* tag::                         Add a tag to checked out version
* update::                      Bring work tree in sync with repository


File: cvs.info,  Node: Structure,  Next: ~/.cvsrc,  Up: Invoking CVS

Overall structure of CVS commands
=================================

   The first release of CVS consisted of a number of shell-scripts.
Today CVS is implemented as a single program that is a front-end to RCS
and `diff'. The overall format of all CVS commands is:

     cvs [ cvs_options ] cvs_command [ command_options ] [ command_args ]

`cvs'
     The program that is a front-end to RCS.

`cvs_options'
     Some options that affect all sub-commands of CVS.  These are
     described below.

`cvs_command'
     One of several different sub-commands.  Some of the commands have
     aliases that can be used instead; those aliases are noted in the
     reference manual for that command.  There are only two situations
     where you may omit `cvs_command': `cvs -H' elicits a list of
     available commands, and `cvs -v' displays version information on
     CVS itself.

`command_options'
     Options that are specific for the command.

`command_args'
     Arguments to the commands.

   There is unfortunately some confusion between `cvs_options' and
`command_options'.  `-l', when given as a `cvs_option', only affects
some of the commands.  When it is given as a `command_option' is has a
different meaning, and is accepted by more commands.  In other words,
do not take the above categorization too seriously.  Look at the
documentation instead.


File: cvs.info,  Node: ~/.cvsrc,  Next: Global options,  Prev: Structure,  Up: Invoking CVS

Default options and the ~/.cvsrc file
=====================================

   There are some `command_options' that are used so often that you
might have set up an alias or some other means to make sure you always
specify that option.  One example (1) is that many people find the
default output of the `diff' command to be very hard to read, and that
either context diffs or unidiffs are much easier to understand.

   The `~/.cvsrc' file is a way that you can add default options to
`cvs_commands' within cvs, instead of relying on aliases or other shell
scripts.

   The format of the `~/.cvsrc' file is simple.  The file is searched
for a line that begins with the same name as the `cvs_command' being
executed.  If a match is found, then the remainder of the line is split
up (at whitespace characters) into separate options and added to the
command arguments *before* any options from the command line.

   If a command has two names (e.g., `checkout' and `co'), only the
name used on the command line will be used to match against the file.
So if this is the contents of the user's `~/.cvsrc' file:

     log -N
     diff -u
     update -P
     co -P

the command `cvs checkout foo' would not have the `-P' option added to
the arguments, while `cvs co foo' would.

   With the example file above, the output from `cvs diff foobar' will
be in unidiff format.  `cvs diff -c foobar' will provide context diffs,
as usual.  Since `diff' doesn't have an option to specify use of the
"old" format, you would need to use the `-f' option to `cvs' to turn
off use of the `~/.cvsrc' options.

   ---------- Footnotes ----------

   (1)  being the one that drove the implementation of the .cvsrc
support


File: cvs.info,  Node: Global options,  Next: Common options,  Prev: ~/.cvsrc,  Up: Invoking CVS

Global options
==============

   The available `cvs_options' (that are given to the left of
`cvs_command') are:

`-b BINDIR'
     Use BINDIR as the directory where RCS programs are located.
     Overrides the setting of the `$RCSBIN' environment variable and
     any precompiled directory.  This parameter should be specified as
     an absolute pathname.

`-d CVS_ROOT_DIRECTORY'
     Use CVS_ROOT_DIRECTORY as the root directory pathname of the
     repository.  Overrides the setting of the `$CVSROOT' environment
     variable.  This parameter should be specified as an absolute
     pathname.

`-e EDITOR'
     Use EDITOR to enter revision log information.  Overrides the
     setting of the `$CVSEDITOR' and `$EDITOR' environment variables.

`-f'
     Do not read the `~/.cvsrc' file.  This option is most often used
     because of the non-orthogonality of the CVS option set.  For
     example, the `cvs log' option `-N' (turn off display of tag names)
     does not have a corresponding option to turn the display on.  So
     if you have `-N' in the `~/.cvsrc' entry for `diff', you may need
     to use `-f' to show the tag names.  (1)

`-H'
     Display usage information about the specified `cvs_command' (but
     do not actually execute the command).  If you don't specify a
     command name, `cvs -H' displays a summary of all the commands
     available.

`-l'
     Do not log the cvs_command in the command history (but execute it
     anyway).  *Note history::, for information on command history.

`-n'
     Do not change any files.  Attempt to execute the `cvs_command',
     but only to issue reports; do not remove, update, or merge any
     existing files, or create any new files.

`-Q'
     Cause the command to be really quiet; the command will only
     generate output for serious problems.

`-q'
     Cause the command to be somewhat quiet; informational messages,
     such as reports of recursion through subdirectories, are
     suppressed.

`-r'
     Make new working files files read-only.  Same effect as if the
     `$CVSREAD' environment variable is set (*note Environment
     variables::.).  The default is to make working files writable.

`-t'
     Trace program execution; display messages showing the steps of CVS
     activity.  Particularly useful with `-n' to explore the potential
     impact of an unfamiliar command.

`-v'
     Display version and copyright information for CVS.

`-w'
     Make new working files read-write.  Overrides the setting of the
     `$CVSREAD' environment variable.  Files are created read-write by
     default, unless `$CVSREAD' is set or `-r' is given.

   ---------- Footnotes ----------

   (1)  Yes, this really should be fixed, and it's being worked on


File: cvs.info,  Node: Common options,  Next: add,  Prev: Global options,  Up: Invoking CVS

Common command options
======================

   This section describes the `command_options' that are available
across several CVS commands.  These options are always given to the
right of `cvs_command'. Not all commands support all of these options;
each option is only supported for commands where it makes sense.
However, when a command has one of these options you can almost always
count on the same behavior of the option as in other commands.  (Other
command options, which are listed with the individual commands, may have
different behavior from one CVS command to the other).

   *Warning:* the `history' command is an exception; it supports many
options that conflict even with these standard options.

`-D DATE_SPEC'
     Use the most recent revision no later than DATE_SPEC.  DATE_SPEC
     is a single argument, a date description specifying a date in the
     past.

     The specification is "sticky" when you use it to make a private
     copy of a source file; that is, when you get a working file using
     `-D', CVS records the date you specified, so that further updates
     in the same directory will use the same date (unless you
     explicitly override it; *note update::.).

     A wide variety of date formats are supported by the underlying RCS
     facilities, similar to those described in co(1), but not exactly
     the same.  The DATE_SPEC is interpreted as being in the local
     timezone, unless a specific timezone is specified.  Examples of
     valid date specifications include:

                              1 month ago
                              2 hours ago
                              400000 seconds ago
                              last year
                              last Monday
                              yesterday
                              a fortnight ago
                              3/31/92 10:00:07 PST
                              January 23, 1987 10:05pm
                              22:00 GMT

     `-D' is available with the `checkout', `diff', `export', `history',
     `rdiff', `rtag', and `update' commands.  (The `history' command
     uses this option in a slightly different way; *note history
     options::.).

     Remember to quote the argument to the `-D' flag so that your shell
     doesn't interpret spaces as argument separators.  A command using
     the `-D' flag can look like this:

          $ cvs diff -D "1 hour ago" cvs.texinfo

`-f'
     When you specify a particular date or tag to CVS commands, they
     normally ignore files that do not contain the tag (or did not
     exist prior to the date) that you specified.  Use the `-f' option
     if you want files retrieved even when there is no match for the
     tag or date.  (The most recent revision of the file will be used).

     `-f' is available with these commands: `checkout', `export',
     `rdiff', `rtag', and `update'.

     *Warning:*  The `commit' command also has a `-f' option, but it
     has a different behavior for that command.  *Note commit options::.

`-H'
     Help; describe the options available for this command.  This is
     the only option supported for all CVS commands.

`-k KFLAG'
     Alter the default RCS processing of keywords.  *Note Keyword
     substitution::, for the meaning of KFLAG.  Your KFLAG
     specification is "sticky" when you use it to create a private copy
     of a source file; that is, when you use this option with the
     `checkout' or `update' commands, CVS associates your selected
     KFLAG with the file, and continues to use it with future update
     commands on the same file until you specify otherwise.

     The `-k' option is available with the `add', `checkout', `diff' and
     `update' commands.

`-l'
     Local; run only in current working directory, rather than
     recursing through subdirectories.

     *Warning:* this is not the same as the overall `cvs -l' option,
     which you can specify to the left of a cvs command!

     Available with the following commands: `checkout', `commit',
     `diff', `export', `log', `remove', `rdiff', `rtag', `status',
     `tag', and `update'.

`-m MESSAGE'
     Use MESSAGE as log information, instead of invoking an editor.

     Available with the following commands: `add', `commit' and
     `import'.

`-n'
     Do not run any checkout/commit/tag program.  (A program can be
     specified to run on each of these activities, in the modules
     database (*note modules::.); this option bypasses it).

     *Warning:* this is not the same as the overall `cvs -n' option,
     which you can specify to the left of a cvs command!

     Available with the `checkout', `commit', `export', and `rtag'
     commands.

`-P'
     Prune (remove) directories that are empty after being updated, on
     `checkout', or `update'.  Normally, an empty directory (one that
     is void of revision-controlled files) is left alone.  Specifying
     `-P' will cause these directories to be silently removed from your
     checked-out sources.  This does not remove the directory from the
     repository, only from your checked out copy.  Note that this
     option is implied by the `-r' or `-D' options of `checkout' and
     `export'.

`-p'
     Pipe the files retrieved from the repository to standard output,
     rather than writing them in the current directory.  Available with
     the `checkout' and `update' commands.

`-W'
     Specify file names that should be filtered.  You can use this
     option repeatedly.  The spec can be a file name pattern of the
     same type that you can specify in the `.cvswrappers' file.
     Avaliable with the following commands: `import', and `update'.

`-r TAG'
     Use the revision specified by the TAG argument instead of the
     default "head" revision.  As well as arbitrary tags defined with
     the `tag' or `rtag' command, two special tags are always
     available: `HEAD' refers to the most recent version available in
     the repository, and `BASE' refers to the revision you last checked
     out into the current working directory.

     The tag specification is sticky when you use this option with
     `checkout' or `update' to make your own copy of a file: CVS
     remembers the tag and continues to use it on future update
     commands, until you specify otherwise.  The tag can be either a
     symbolic or numeric tag.  *Note Tags::.

     Specifying the `-q' global option along with the `-r' command
     option is often useful, to suppress the warning messages when the
     RCS history file does not contain the specified tag.

     *Warning:* this is not the same as the overall `cvs -r' option,
     which you can specify to the left of a cvs command!

     `-r' is available with the `checkout', `commit', `diff',
     `history', `export', `rdiff', `rtag', and `update' commands.


File: cvs.info,  Node: add,  Next: admin,  Prev: Common options,  Up: Invoking CVS

add--Add a new file/directory to the repository
===============================================

   * Synopsis: add [-k kflag] [-m 'message'] files...

   * Requires: repository, working directory.

   * Changes: working directory.

   * Synonym: new

   Use the `add' command to create a new file or directory in the
source repository.  The files or directories specified with `add' must
already exist in the current directory (which must have been created
with the `checkout' command).  To add a whole new directory hierarchy
to the source repository (for example, files received from a
third-party vendor), use the `import' command instead.  *Note import::.

   If the argument to `add' refers to an immediate sub-directory, the
directory is created at the correct place in the source repository, and
the necessary CVS administration files are created in your working
directory.  If the directory already exists in the source repository,
`add' still creates the administration files in your version of the
directory.  This allows you to use `add' to add a particular directory
to your private sources even if someone else created that directory
after your checkout of the sources.  You can do the following:

     $ mkdir new_directory
     $ cvs add new_directory
     $ cvs update new_directory

   An alternate approach using `update' might be:

     $ cvs update -d new_directory

   (To add any available new directories to your working directory,
it's probably simpler to use `checkout' (*note checkout::.) or `update
-d' (*note update::.)).

   The added files are not placed in the source repository until you
use `commit' to make the change permanent.  Doing an `add' on a file
that was removed with the `remove' command will resurrect the file,
unless a `commit' command intervened.  *Note remove examples:: for an
example.

   Unlike most other commands `add' never recurses down directories.
It cannot yet handle relative paths.  Instead of

     $ cvs add foo/bar.c

   you have to do

     $ cd foo
     $ cvs add bar.c

* Menu:

* add options::                 add options
* add examples::                add examples

