This is Info file bfd.info, produced by Makeinfo-1.64 from the input
file ./bfd.texinfo.

START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, subject to the
terms of the GNU General Public License, which includes the provision
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: bfd.info,  Node: section prototypes,  Prev: typedef asection,  Up: Sections

Section prototypes
------------------

   These are the functions exported by the section handling part of BFD.
`bfd_get_section_by_name'
.........................

*Synopsis*
     asection *bfd_get_section_by_name(bfd *abfd, CONST char *name);
   *Description*
Run through ABFD and return the one of the `asection's whose name
matches NAME, otherwise `NULL'.  *Note Sections::, for more information.

   This should only be used in special cases; the normal way to process
all sections of a given name is to use `bfd_map_over_sections' and
`strcmp' on the name (or better yet, base it on the section flags or
something else) for each section.
`bfd_make_section_old_way'
..........................

*Synopsis*
     asection *bfd_make_section_old_way(bfd *abfd, CONST char *name);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for the BFD ABFD. An attempt to create a section with
a name which is already in use returns its pointer without changing the
section chain.

   It has the funny name since this is the way it used to be before it
was rewritten....

   Possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     this BFD.

   * `bfd_error_no_memory' - If memory allocation fails.
`bfd_make_section_anyway'
.........................

*Synopsis*
     asection *bfd_make_section_anyway(bfd *abfd, CONST char *name);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for ABFD.  Create a new section even if there is
already a section with that name.

   Return `NULL' and set `bfd_error' on error; possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     ABFD.

   * `bfd_error_no_memory' - If memory allocation fails.
`bfd_make_section'
..................

*Synopsis*
     asection *bfd_make_section(bfd *, CONST char *name);
   *Description*
Like `bfd_make_section_anyway', but return `NULL' (without calling
bfd_set_error ()) without changing the section chain if there is
already a section named NAME.  If there is an error, return `NULL' and
set `bfd_error'.
`bfd_set_section_flags'
.......................

*Synopsis*
     boolean bfd_set_section_flags(bfd *abfd, asection *sec, flagword flags);
   *Description*
Set the attributes of the section SEC in the BFD ABFD to the value
FLAGS. Return `true' on success, `false' on error. Possible error
returns are:

   * `bfd_error_invalid_operation' - The section cannot have one or
     more of the attributes requested. For example, a .bss section in
     `a.out' may not have the `SEC_HAS_CONTENTS' field set.
`bfd_map_over_sections'
.......................

*Synopsis*
     void bfd_map_over_sections(bfd *abfd,
         void (*func)(bfd *abfd,
         asection *sect,
         PTR obj),
         PTR obj);
   *Description*
Call the provided function FUNC for each section attached to the BFD
ABFD, passing OBJ as an argument. The function will be called as if by

     	func(abfd, the_section, obj);

   This is the prefered method for iterating over sections; an
alternative would be to use a loop:

     	   section *p;
     	   for (p = abfd->sections; p != NULL; p = p->next)
     	      func(abfd, p, ...)

`bfd_set_section_size'
......................

*Synopsis*
     boolean bfd_set_section_size(bfd *abfd, asection *sec, bfd_size_type val);
   *Description*
Set SEC to the size VAL. If the operation is ok, then `true' is
returned, else `false'.

   Possible error returns:
   * `bfd_error_invalid_operation' - Writing has started to the BFD, so
     setting the size is invalid.
`bfd_set_section_contents'
..........................

*Synopsis*
     boolean bfd_set_section_contents
        (bfd *abfd,
         asection *section,
         PTR data,
         file_ptr offset,
         bfd_size_type count);
   *Description*
Sets the contents of the section SECTION in BFD ABFD to the data
starting in memory at DATA. The data is written to the output section
starting at offset OFFSET for COUNT bytes.

   Normally `true' is returned, else `false'. Possible error returns
are:
   * `bfd_error_no_contents' - The output section does not have the
     `SEC_HAS_CONTENTS' attribute, so nothing can be written to it.

   * and some more too This routine is front end to the back end
function `_bfd_set_section_contents'.
`bfd_get_section_contents'
..........................

*Synopsis*
     boolean bfd_get_section_contents
        (bfd *abfd, asection *section, PTR location,
         file_ptr offset, bfd_size_type count);
   *Description*
Read data from SECTION in BFD ABFD into memory starting at LOCATION.
The data is read at an offset of OFFSET from the start of the input
section, and is read for COUNT bytes.

   If the contents of a constructor with the `SEC_CONSTRUCTOR' flag set
are requested or if the section does not have the `SEC_HAS_CONTENTS'
flag set, then the LOCATION is filled with zeroes. If no errors occur,
`true' is returned, else `false'.
`bfd_copy_private_section_data'
...............................

*Synopsis*
     boolean bfd_copy_private_section_data(bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
   *Description*
Copy private section information from ISEC in the BFD IBFD to the
section OSEC in the BFD OBFD.  Return `true' on success, `false' on
error.  Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OSEC.
     #define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
          BFD_SEND (obfd, _bfd_copy_private_section_data, \
     		(ibfd, isection, obfd, osection))


File: bfd.info,  Node: Symbols,  Next: Archives,  Prev: Sections,  Up: BFD front end

Symbols
=======

BFD tries to maintain as much symbol information as it can when it
moves information from file to file. BFD passes information to
applications though the `asymbol' structure. When the application
requests the symbol table, BFD reads the table in the native form and
translates parts of it into the internal format. To maintain more than
the information passed to applications, some targets keep some
information "behind the scenes" in a structure only the particular back
end knows about. For example, the coff back end keeps the original
symbol table structure as well as the canonical structure when a BFD is
read in. On output, the coff back end can reconstruct the output symbol
table so that no information is lost, even information unique to coff
which BFD doesn't know or understand. If a coff symbol table were read,
but were written through an a.out back end, all the coff specific
information would be lost. The symbol table of a BFD is not necessarily
read in until a canonicalize request is made. Then the BFD back end
fills in a table provided by the application with pointers to the
canonical information.  To output symbols, the application provides BFD
with a table of pointers to pointers to `asymbol's. This allows
applications like the linker to output a symbol as it was read, since
the "behind the scenes" information will be still available.

* Menu:

* Reading Symbols::
* Writing Symbols::
* Mini Symbols::
* typedef asymbol::
* symbol handling functions::


File: bfd.info,  Node: Reading Symbols,  Next: Writing Symbols,  Prev: Symbols,  Up: Symbols

Reading symbols
---------------

There are two stages to reading a symbol table from a BFD: allocating
storage, and the actual reading process. This is an excerpt from an
application which reads the symbol table:

     	  long storage_needed;
     	  asymbol **symbol_table;
     	  long number_of_symbols;
     	  long i;
     
     	  storage_needed = bfd_get_symtab_upper_bound (abfd);
     
              if (storage_needed < 0)
                FAIL
     
     	  if (storage_needed == 0) {
     	     return ;
     	  }
     	  symbol_table = (asymbol **) xmalloc (storage_needed);
     	    ...
     	  number_of_symbols =
     	     bfd_canonicalize_symtab (abfd, symbol_table);
     
              if (number_of_symbols < 0)
                FAIL
     
     	  for (i = 0; i < number_of_symbols; i++) {
     	     process_symbol (symbol_table[i]);
     	  }

   All storage for the symbols themselves is in an objalloc connected
to the BFD; it is freed when the BFD is closed.

File: bfd.info,  Node: Writing Symbols,  Next: Mini Symbols,  Prev: Reading Symbols,  Up: Symbols

Writing symbols
---------------

Writing of a symbol table is automatic when a BFD open for writing is
closed. The application attaches a vector of pointers to pointers to
symbols to the BFD being written, and fills in the symbol count. The
close and cleanup code reads through the table provided and performs
all the necessary operations. The BFD output code must always be
provided with an "owned" symbol: one which has come from another BFD,
or one which has been created using `bfd_make_empty_symbol'.  Here is an
example showing the creation of a symbol table with only one element:

     	#include "bfd.h"
     	main()
     	{
     	  bfd *abfd;
     	  asymbol *ptrs[2];
     	  asymbol *new;
     
     	  abfd = bfd_openw("foo","a.out-sunos-big");
     	  bfd_set_format(abfd, bfd_object);
     	  new = bfd_make_empty_symbol(abfd);
     	  new->name = "dummy_symbol";
     	  new->section = bfd_make_section_old_way(abfd, ".text");
     	  new->flags = BSF_GLOBAL;
     	  new->value = 0x12345;
     
     	  ptrs[0] = new;
     	  ptrs[1] = (asymbol *)0;
     
     	  bfd_set_symtab(abfd, ptrs, 1);
     	  bfd_close(abfd);
     	}
     
     	./makesym
     	nm foo
     	00012345 A dummy_symbol

   Many formats cannot represent arbitary symbol information; for
instance, the `a.out' object format does not allow an arbitary number
of sections. A symbol pointing to a section which is not one  of
`.text', `.data' or `.bss' cannot be described.

File: bfd.info,  Node: Mini Symbols,  Next: typedef asymbol,  Prev: Writing Symbols,  Up: Symbols

Mini Symbols
------------

Mini symbols provide read-only access to the symbol table.  They use
less memory space, but require more time to access.  They can be useful
for tools like nm or objdump, which may have to handle symbol tables of
extremely large executables.

   The `bfd_read_minisymbols' function will read the symbols into
memory in an internal form.  It will return a `void *' pointer to a
block of memory, a symbol count, and the size of each symbol.  The
pointer is allocated using `malloc', and should be freed by the caller
when it is no longer needed.

   The function `bfd_minisymbol_to_symbol' will take a pointer to a
minisymbol, and a pointer to a structure returned by
`bfd_make_empty_symbol', and return a `asymbol' structure.  The return
value may or may not be the same as the value from
`bfd_make_empty_symbol' which was passed in.

File: bfd.info,  Node: typedef asymbol,  Next: symbol handling functions,  Prev: Mini Symbols,  Up: Symbols

typedef asymbol
---------------

An `asymbol' has the form:
.
     typedef struct symbol_cache_entry
     {
     	/* A pointer to the BFD which owns the symbol. This information
     	   is necessary so that a back end can work out what additional
        	   information (invisible to the application writer) is carried
     	   with the symbol.
     
     	   This field is *almost* redundant, since you can use section->owner
     	   instead, except that some symbols point to the global sections
     	   bfd_{abs,com,und}_section.  This could be fixed by making
     	   these globals be per-bfd (or per-target-flavor).  FIXME. */
     
       struct _bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field. */
     
     	/* The text of the symbol. The name is left alone, and not copied; the
     	   application may not alter it. */
       CONST char *name;
     
     	/* The value of the symbol.  This really should be a union of a
               numeric value with a pointer, since some flags indicate that
               a pointer to another symbol is stored here.  */
       symvalue value;
     
     	/* Attributes of a symbol: */
     
     #define BSF_NO_FLAGS    0x00
     
     	/* The symbol has local scope; `static' in `C'. The value
      	   is the offset into the section of the data. */
     #define BSF_LOCAL	0x01
     
     	/* The symbol has global scope; initialized data in `C'. The
     	   value is the offset into the section of the data. */
     #define BSF_GLOBAL	0x02
     
     	/* The symbol has global scope and is exported. The value is
     	   the offset into the section of the data. */
     #define BSF_EXPORT	BSF_GLOBAL /* no real difference */
     
     	/* A normal C symbol would be one of:
     	   `BSF_LOCAL', `BSF_FORT_COMM',  `BSF_UNDEFINED' or
     	   `BSF_GLOBAL' */
     
     	/* The symbol is a debugging record. The value has an arbitary
     	   meaning. */
     #define BSF_DEBUGGING	0x08
     
     	/* The symbol denotes a function entry point.  Used in ELF,
     	   perhaps others someday.  */
     #define BSF_FUNCTION    0x10
     
     	/* Used by the linker. */
     #define BSF_KEEP        0x20
     #define BSF_KEEP_G      0x40
     
     	/* A weak global symbol, overridable without warnings by
     	   a regular global symbol of the same name.  */
     #define BSF_WEAK        0x80
     
            /* This symbol was created to point to a section, e.g. ELF's
     	   STT_SECTION symbols.  */
     #define BSF_SECTION_SYM 0x100
     
     	/* The symbol used to be a common symbol, but now it is
     	   allocated. */
     #define BSF_OLD_COMMON  0x200
     
     	/* The default value for common data. */
     #define BFD_FORT_COMM_DEFAULT_VALUE 0
     
     	/* In some files the type of a symbol sometimes alters its
     	   location in an output file - ie in coff a `ISFCN' symbol
     	   which is also `C_EXT' symbol appears where it was
     	   declared and not at the end of a section.  This bit is set
       	   by the target BFD part to convey this information. */
     
     #define BSF_NOT_AT_END    0x400
     
     	/* Signal that the symbol is the label of constructor section. */
     #define BSF_CONSTRUCTOR   0x800
     
     	/* Signal that the symbol is a warning symbol.  The name is a
     	   warning.  The name of the next symbol is the one to warn about;
     	   if a reference is made to a symbol with the same name as the next
     	   symbol, a warning is issued by the linker. */
     #define BSF_WARNING       0x1000
     
     	/* Signal that the symbol is indirect.  This symbol is an indirect
     	   pointer to the symbol with the same name as the next symbol. */
     #define BSF_INDIRECT      0x2000
     
     	/* BSF_FILE marks symbols that contain a file name.  This is used
     	   for ELF STT_FILE symbols.  */
     #define BSF_FILE          0x4000
     
     	/* Symbol is from dynamic linking information.  */
     #define BSF_DYNAMIC	   0x8000
     
            /* The symbol denotes a data object.  Used in ELF, and perhaps
               others someday.  */
     #define BSF_OBJECT	   0x10000
     
       flagword flags;
     
     	/* A pointer to the section to which this symbol is
     	   relative.  This will always be non NULL, there are special
               sections for undefined and absolute symbols.  */
       struct sec *section;
     
     	/* Back end special data.  */
       union
         {
           PTR p;
           bfd_vma i;
         } udata;
     
     } asymbol;


File: bfd.info,  Node: symbol handling functions,  Prev: typedef asymbol,  Up: Symbols

Symbol handling functions
-------------------------

`bfd_get_symtab_upper_bound'
............................

*Description*
Return the number of bytes required to store a vector of pointers to
`asymbols' for all the symbols in the BFD ABFD, including a terminal
NULL pointer. If there are no symbols in the BFD, then return 0.  If an
error occurs, return -1.
     #define bfd_get_symtab_upper_bound(abfd) \
          BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))

`bfd_is_local_label'
....................

*Synopsis*
     boolean bfd_is_local_label(bfd *abfd, asymbol *sym);
   *Description*
Return true if the given symbol SYM in the BFD ABFD is a compiler
generated local label, else return false.
`bfd_is_local_label_name'
.........................

*Synopsis*
     boolean bfd_is_local_label_name(bfd *abfd, const char *name);
   *Description*
Return true if a symbol with the name NAME in the BFD ABFD is a
compiler generated local label, else return false.  This just checks
whether the name has the form of a local label.
     #define bfd_is_local_label_name(abfd, name) \
          BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))

`bfd_canonicalize_symtab'
.........................

*Description*
Read the symbols from the BFD ABFD, and fills in the vector LOCATION
with pointers to the symbols and a trailing NULL.  Return the actual
number of symbol pointers, not including the NULL.
     #define bfd_canonicalize_symtab(abfd, location) \
          BFD_SEND (abfd, _bfd_canonicalize_symtab,\
                       (abfd, location))

`bfd_set_symtab'
................

*Synopsis*
     boolean bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int count);
   *Description*
Arrange that when the output BFD ABFD is closed, the table LOCATION of
COUNT pointers to symbols will be written.
`bfd_print_symbol_vandf'
........................

*Synopsis*
     void bfd_print_symbol_vandf(PTR file, asymbol *symbol);
   *Description*
Print the value and flags of the SYMBOL supplied to the stream FILE.
`bfd_make_empty_symbol'
.......................

*Description*
Create a new `asymbol' structure for the BFD ABFD and return a pointer
to it.

   This routine is necessary because each back end has private
information surrounding the `asymbol'. Building your own `asymbol' and
pointing to it will not create the private information, and will cause
problems later on.
     #define bfd_make_empty_symbol(abfd) \
          BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))

`bfd_make_debug_symbol'
.......................

*Description*
Create a new `asymbol' structure for the BFD ABFD, to be used as a
debugging symbol.  Further details of its use have yet to be worked out.
     #define bfd_make_debug_symbol(abfd,ptr,size) \
             BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))

`bfd_decode_symclass'
.....................

*Description*
Return a character corresponding to the symbol class of SYMBOL, or '?'
for an unknown class.
*Synopsis*
     int bfd_decode_symclass(asymbol *symbol);

`bfd_symbol_info'
.................

   *Description*
Fill in the basic info about symbol that nm needs.  Additional info may
be added by the back-ends after calling this function.
*Synopsis*
     void bfd_symbol_info(asymbol *symbol, symbol_info *ret);

`bfd_copy_private_symbol_data'
..............................

   *Synopsis*
     boolean bfd_copy_private_symbol_data(bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
   *Description*
Copy private symbol information from ISYM in the BFD IBFD to the symbol
OSYM in the BFD OBFD.  Return `true' on success, `false' on error.
Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OSEC.
     #define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
          BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
     		(ibfd, isymbol, obfd, osymbol))


File: bfd.info,  Node: Archives,  Next: Formats,  Prev: Symbols,  Up: BFD front end

Archives
========

*Description*
An archive (or library) is just another BFD.  It has a symbol table,
although there's not much a user program will do with it.

   The big difference between an archive BFD and an ordinary BFD is
that the archive doesn't have sections.  Instead it has a chain of BFDs
that are considered its contents.  These BFDs can be manipulated like
any other.  The BFDs contained in an archive opened for reading will
all be opened for reading.  You may put either input or output BFDs
into an archive opened for output; they will be handled correctly when
the archive is closed.

   Use `bfd_openr_next_archived_file' to step through the contents of
an archive opened for input.  You don't have to read the entire archive
if you don't want to!  Read it until you find what you want.

   Archive contents of output BFDs are chained through the `next'
pointer in a BFD.  The first one is findable through the `archive_head'
slot of the archive.  Set it with `bfd_set_archive_head' (q.v.).  A
given BFD may be in only one open output archive at a time.

   As expected, the BFD archive code is more general than the archive
code of any given environment.  BFD archives may contain files of
different formats (e.g., a.out and coff) and even different
architectures.  You may even place archives recursively into archives!

   This can cause unexpected confusion, since some archive formats are
more expressive than others.  For instance, Intel COFF archives can
preserve long filenames; SunOS a.out archives cannot.  If you move a
file from the first to the second format and back again, the filename
may be truncated.  Likewise, different a.out environments have different
conventions as to how they truncate filenames, whether they preserve
directory names in filenames, etc.  When interoperating with native
tools, be sure your files are homogeneous.

   Beware: most of these formats do not react well to the presence of
spaces in filenames.  We do the best we can, but can't always handle
this case due to restrictions in the format of archives.  Many Unix
utilities are braindead in regards to spaces and such in filenames
anyway, so this shouldn't be much of a restriction.

   Archives are supported in BFD in `archive.c'.
`bfd_get_next_mapent'
.....................

*Synopsis*
     symindex bfd_get_next_mapent(bfd *abfd, symindex previous, carsym **sym);
   *Description*
Step through archive ABFD's symbol table (if it has one).  Successively
update SYM with the next symbol's information, returning that symbol's
(internal) index into the symbol table.

   Supply `BFD_NO_MORE_SYMBOLS' as the PREVIOUS entry to get the first
one; returns `BFD_NO_MORE_SYMBOLS' when you've already got the last one.

   A `carsym' is a canonical archive symbol.  The only user-visible
element is its name, a null-terminated string.
`bfd_set_archive_head'
......................

*Synopsis*
     boolean bfd_set_archive_head(bfd *output, bfd *new_head);
   *Description*
Set the head of the chain of BFDs contained in the archive OUTPUT to
NEW_HEAD.
`bfd_openr_next_archived_file'
..............................

*Synopsis*
     bfd *bfd_openr_next_archived_file(bfd *archive, bfd *previous);
   *Description*
Provided a BFD, ARCHIVE, containing an archive and NULL, open an input
BFD on the first contained element and returns that.  Subsequent calls
should pass the archive and the previous return value to return a
created BFD to the next contained element. NULL is returned when there
are no more.

File: bfd.info,  Node: Formats,  Next: Relocations,  Prev: Archives,  Up: BFD front end

File formats
============

A format is a BFD concept of high level file contents type. The formats
supported by BFD are:

   * `bfd_object' The BFD may contain data, symbols, relocations and
debug info.

   * `bfd_archive' The BFD contains other BFDs and an optional index.

   * `bfd_core' The BFD contains the result of an executable core dump.
`bfd_check_format'
..................

*Synopsis*
     boolean bfd_check_format(bfd *abfd, bfd_format format);
   *Description*
Verify if the file attached to the BFD ABFD is compatible with the
format FORMAT (i.e., one of `bfd_object', `bfd_archive' or `bfd_core').

   If the BFD has been set to a specific target before the call, only
the named target and format combination is checked. If the target has
not been set, or has been set to `default', then all the known target
backends is interrogated to determine a match.  If the default target
matches, it is used.  If not, exactly one target must recognize the
file, or an error results.

   The function returns `true' on success, otherwise `false' with one
of the following error codes:

   * `bfd_error_invalid_operation' - if `format' is not one of
     `bfd_object', `bfd_archive' or `bfd_core'.

   * `bfd_error_system_call' - if an error occured during a read - even
     some file mismatches can cause bfd_error_system_calls.

   * `file_not_recognised' - none of the backends recognised the file
     format.

   * `bfd_error_file_ambiguously_recognized' - more than one backend
     recognised the file format.
`bfd_check_format_matches'
..........................

*Synopsis*
     boolean bfd_check_format_matches(bfd *abfd, bfd_format format, char ***matching);
   *Description*
Like `bfd_check_format', except when it returns false with `bfd_errno'
set to `bfd_error_file_ambiguously_recognized'.  In that case, if
MATCHING is not NULL, it will be filled in with a NULL-terminated list
of the names of the formats that matched, allocated with `malloc'.
Then the user may choose a format and try again.

   When done with the list that MATCHING points to, the caller should
free it.
`bfd_set_format'
................

*Synopsis*
     boolean bfd_set_format(bfd *abfd, bfd_format format);
   *Description*
This function sets the file format of the BFD ABFD to the format
FORMAT. If the target set in the BFD does not support the format
requested, the format is invalid, or the BFD is not open for writing,
then an error occurs.
`bfd_format_string'
...................

*Synopsis*
     CONST char *bfd_format_string(bfd_format format);
   *Description*
Return a pointer to a const string `invalid', `object', `archive',
`core', or `unknown', depending upon the value of FORMAT.

File: bfd.info,  Node: Relocations,  Next: Core Files,  Prev: Formats,  Up: BFD front end

Relocations
===========

BFD maintains relocations in much the same way it maintains symbols:
they are left alone until required, then read in en-mass and translated
into an internal form.  A common routine `bfd_perform_relocation' acts
upon the canonical form to do the fixup.

   Relocations are maintained on a per section basis, while symbols are
maintained on a per BFD basis.

   All that a back end has to do to fit the BFD interface is to create
a `struct reloc_cache_entry' for each relocation in a particular
section, and fill in the right bits of the structures.

* Menu:

* typedef arelent::
* howto manager::


File: bfd.info,  Node: typedef arelent,  Next: howto manager,  Prev: Relocations,  Up: Relocations

typedef arelent
---------------

This is the structure of a relocation entry:
.
     typedef enum bfd_reloc_status
     {
            /* No errors detected */
       bfd_reloc_ok,
     
            /* The relocation was performed, but there was an overflow. */
       bfd_reloc_overflow,
     
            /* The address to relocate was not within the section supplied. */
       bfd_reloc_outofrange,
     
            /* Used by special functions */
       bfd_reloc_continue,
     
            /* Unsupported relocation size requested. */
       bfd_reloc_notsupported,
     
            /* Unused */
       bfd_reloc_other,
     
            /* The symbol to relocate against was undefined. */
       bfd_reloc_undefined,
     
            /* The relocation was performed, but may not be ok - presently
               generated only when linking i960 coff files with i960 b.out
               symbols.  If this type is returned, the error_message argument
               to bfd_perform_relocation will be set.  */
       bfd_reloc_dangerous
      }
      bfd_reloc_status_type;
     
     
     typedef struct reloc_cache_entry
     {
            /* A pointer into the canonical table of pointers  */
       struct symbol_cache_entry **sym_ptr_ptr;
     
            /* offset in section */
       bfd_size_type address;
     
            /* addend for relocation value */
       bfd_vma addend;
     
            /* Pointer to how to perform the required relocation */
       reloc_howto_type *howto;
     
     } arelent;
   *Description*
Here is a description of each of the fields within an `arelent':

   * `sym_ptr_ptr' The symbol table pointer points to a pointer to the
symbol associated with the relocation request.  It is the pointer into
the table returned by the back end's `get_symtab' action. *Note
Symbols::. The symbol is referenced through a pointer to a pointer so
that tools like the linker can fix up all the symbols of the same name
by modifying only one pointer. The relocation routine looks in the
symbol and uses the base of the section the symbol is attached to and
the value of the symbol as the initial relocation offset. If the symbol
pointer is zero, then the section provided is looked up.

   * `address' The `address' field gives the offset in bytes from the
base of the section data which owns the relocation record to the first
byte of relocatable information. The actual data relocated will be
relative to this point; for example, a relocation type which modifies
the bottom two bytes of a four byte word would not touch the first byte
pointed to in a big endian world.

   * `addend' The `addend' is a value provided by the back end to be
added (!) to the relocation offset. Its interpretation is dependent upon
the howto. For example, on the 68k the code:

             char foo[];
             main()
                     {
                     return foo[0x12345678];
                     }

   Could be compiled into:

             linkw fp,#-4
             moveb @#12345678,d0
             extbl d0
             unlk fp
             rts

   This could create a reloc pointing to `foo', but leave the offset in
the data, something like:

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000006 32        _foo
     
     00000000 4e56 fffc          ; linkw fp,#-4
     00000004 1039 1234 5678     ; moveb @#12345678,d0
     0000000a 49c0               ; extbl d0
     0000000c 4e5e               ; unlk fp
     0000000e 4e75               ; rts

   Using coff and an 88k, some instructions don't have enough space in
them to represent the full address range, and pointers have to be
loaded in two parts. So you'd get something like:

             or.u     r13,r0,hi16(_foo+0x12345678)
             ld.b     r2,r13,lo16(_foo+0x12345678)
             jmp      r1

   This should create two relocs, both pointing to `_foo', and with
0x12340000 in their addend field. The data would consist of:

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000002 HVRT16    _foo+0x12340000
     00000006 LVRT16    _foo+0x12340000
     
     00000000 5da05678           ; or.u r13,r0,0x5678
     00000004 1c4d5678           ; ld.b r2,r13,0x5678
     00000008 f400c001           ; jmp r1

   The relocation routine digs out the value from the data, adds it to
the addend to get the original offset, and then adds the value of
`_foo'. Note that all 32 bits have to be kept around somewhere, to cope
with carry from bit 15 to bit 16.

   One further example is the sparc and the a.out format. The sparc has
a similar problem to the 88k, in that some instructions don't have room
for an entire offset, but on the sparc the parts are created in odd
sized lumps. The designers of the a.out format chose to not use the
data within the section for storing part of the offset; all the offset
is kept within the reloc. Anything in the data should be ignored.

             save %sp,-112,%sp
             sethi %hi(_foo+0x12345678),%g2
             ldsb [%g2+%lo(_foo+0x12345678)],%i0
             ret
             restore

   Both relocs contain a pointer to `foo', and the offsets contain junk.

     RELOCATION RECORDS FOR [.text]:
     offset   type      value
     00000004 HI22      _foo+0x12345678
     00000008 LO10      _foo+0x12345678
     
     00000000 9de3bf90     ; save %sp,-112,%sp
     00000004 05000000     ; sethi %hi(_foo+0),%g2
     00000008 f048a000     ; ldsb [%g2+%lo(_foo+0)],%i0
     0000000c 81c7e008     ; ret
     00000010 81e80000     ; restore

   * `howto' The `howto' field can be imagined as a relocation
instruction. It is a pointer to a structure which contains information
on what to do with all of the other information in the reloc record and
data section. A back end would normally have a relocation instruction
set and turn relocations into pointers to the correct structure on
input - but it would be possible to create each howto field on demand.
`enum complain_overflow'
........................

Indicates what sort of overflow checking should be done when performing
a relocation.
.
     enum complain_overflow
     {
     	/* Do not complain on overflow. */
       complain_overflow_dont,
     
     	/* Complain if the bitfield overflows, whether it is considered
     	   as signed or unsigned. */
       complain_overflow_bitfield,
     
     	/* Complain if the value overflows when considered as signed
     	   number. */
       complain_overflow_signed,
     
     	/* Complain if the value overflows when considered as an
     	   unsigned number. */
       complain_overflow_unsigned
     };

`reloc_howto_type'
..................

   The `reloc_howto_type' is a structure which contains all the
information that libbfd needs to know to tie up a back end's data.
.struct symbol_cache_entry;		/* Forward declaration */

     struct reloc_howto_struct
     {
            /*  The type field has mainly a documentary use - the back end can
                do what it wants with it, though normally the back end's
                external idea of what a reloc number is stored
                in this field. For example, a PC relative word relocation
                in a coff environment has the type 023 - because that's
                what the outside world calls a R_PCRWORD reloc. */
       unsigned int type;
     
            /*  The value the final relocation is shifted right by. This drops
                unwanted data from the relocation.  */
       unsigned int rightshift;
     
     	/*  The size of the item to be relocated.  This is *not* a
     	    power-of-two measure.  To get the number of bytes operated
     	    on by a type of relocation, use bfd_get_reloc_size.  */
       int size;
     
            /*  The number of bits in the item to be relocated.  This is used
     	    when doing overflow checking.  */
       unsigned int bitsize;
     
            /*  Notes that the relocation is relative to the location in the
                data section of the addend. The relocation function will
                subtract from the relocation value the address of the location
                being relocated. */
       boolean pc_relative;
     
     	/*  The bit position of the reloc value in the destination.
     	    The relocated value is left shifted by this amount. */
       unsigned int bitpos;
     
     	/* What type of overflow error should be checked for when
     	   relocating. */
       enum complain_overflow complain_on_overflow;
     
            /* If this field is non null, then the supplied function is
               called rather than the normal function. This allows really
               strange relocation methods to be accomodated (e.g., i960 callj
               instructions). */
       bfd_reloc_status_type (*special_function)
     				    PARAMS ((bfd *abfd,
     					     arelent *reloc_entry,
                                                 struct symbol_cache_entry *symbol,
                                                 PTR data,
                                                 asection *input_section,
                                                 bfd *output_bfd,
                                                 char **error_message));
     
            /* The textual name of the relocation type. */
       char *name;
     
            /* When performing a partial link, some formats must modify the
               relocations rather than the data - this flag signals this.*/
       boolean partial_inplace;
     
            /* The src_mask selects which parts of the read in data
               are to be used in the relocation sum.  E.g., if this was an 8 bit
               bit of data which we read and relocated, this would be
               0x000000ff. When we have relocs which have an addend, such as
               sun4 extended relocs, the value in the offset part of a
               relocating field is garbage so we never use it. In this case
               the mask would be 0x00000000. */
       bfd_vma src_mask;
     
            /* The dst_mask selects which parts of the instruction are replaced
               into the instruction. In most cases src_mask == dst_mask,
               except in the above special case, where dst_mask would be
               0x000000ff, and src_mask would be 0x00000000.   */
       bfd_vma dst_mask;
     
            /* When some formats create PC relative instructions, they leave
               the value of the pc of the place being relocated in the offset
               slot of the instruction, so that a PC relative relocation can
               be made just by adding in an ordinary offset (e.g., sun3 a.out).
               Some formats leave the displacement part of an instruction
               empty (e.g., m88k bcs); this flag signals the fact.*/
       boolean pcrel_offset;
     
     };

`The HOWTO Macro'
.................

   *Description*
The HOWTO define is horrible and will go away.
     #define HOWTO(C, R,S,B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
       {(unsigned)C,R,S,B, P, BI, O,SF,NAME,INPLACE,MASKSRC,MASKDST,PC}

*Description*
And will be replaced with the totally magic way. But for the moment, we
are compatible, so do it this way.
     #define NEWHOWTO( FUNCTION, NAME,SIZE,REL,IN) HOWTO(0,0,SIZE,0,REL,0,complain_overflow_dont,FUNCTION, NAME,false,0,0,IN)

*Description*
Helper routine to turn a symbol into a relocation value.
     #define HOWTO_PREPARE(relocation, symbol)      \
       {                                            \
       if (symbol != (asymbol *)NULL) {             \
         if (bfd_is_com_section (symbol->section)) { \
           relocation = 0;                          \
         }                                          \
         else {                                     \
           relocation = symbol->value;              \
         }                                          \
       }                                            \
     }

`bfd_get_reloc_size'
....................

*Synopsis*
     int bfd_get_reloc_size (reloc_howto_type *);
   *Description*
For a reloc_howto_type that operates on a fixed number of bytes, this
returns the number of bytes operated on.
`arelent_chain'
...............

*Description*
How relocs are tied together in an `asection':
     typedef struct relent_chain {
       arelent relent;
       struct   relent_chain *next;
     } arelent_chain;

`bfd_perform_relocation'
........................

*Synopsis*
     bfd_reloc_status_type
     bfd_perform_relocation
        (bfd *abfd,
         arelent *reloc_entry,
         PTR data,
         asection *input_section,
         bfd *output_bfd,
         char **error_message);
   *Description*
If OUTPUT_BFD is supplied to this function, the generated image will be
relocatable; the relocations are copied to the output file after they
have been changed to reflect the new state of the world. There are two
ways of reflecting the results of partial linkage in an output file: by
modifying the output data in place, and by modifying the relocation
record.  Some native formats (e.g., basic a.out and basic coff) have no
way of specifying an addend in the relocation type, so the addend has
to go in the output data.  This is no big deal since in these formats
the output data slot will always be big enough for the addend. Complex
reloc types with addends were invented to solve just this problem.  The
ERROR_MESSAGE argument is set to an error message if this return
`bfd_reloc_dangerous'.
`bfd_install_relocation'
........................

*Synopsis*
     bfd_reloc_status_type
     bfd_install_relocation
        (bfd *abfd,
         arelent *reloc_entry,
         PTR data, bfd_vma data_start,
         asection *input_section,
         char **error_message);
   *Description*
This looks remarkably like `bfd_perform_relocation', except it does not
expect that the section contents have been filled in.  I.e., it's
suitable for use when creating, rather than applying a relocation.

   For now, this function should be considered reserved for the
assembler.
