#!./perl
BEGIN { @INC=('./lib', '../lib') }
use File::Find;
use File::Path qw(mkpath);
use Config;
use subs qw(unlink rename link chmod);

$mainperldir = "/usr/bin";
$exe_ext = $Config{exe_ext};

while (@ARGV) {
    $nonono = 1 if $ARGV[0] eq '-n';
    $versiononly = 1 if $ARGV[0] eq '-v';
    shift;
}

umask 022;

@scripts = qw(cppstdin
		utils/c2ph utils/h2ph utils/h2xs utils/pstruct
		utils/perlbug utils/perldoc
		x2p/s2p x2p/find2perl
		pod/pod2man pod/pod2html pod/pod2latex pod/pod2text);

# pod documentation now handled by separate installman script.
# These two are archaic leftovers.
@manpages = qw(x2p/a2p.man x2p/s2p.man);

@pods = (<pod/*.pod>);

$ver = $];
$release = substr($ver,0,3);   # Not used presently.
$patchlevel = substr($ver,3,2);
die "Patchlevel of perl ($patchlevel)",
    "and patchlevel of config.sh ($Config{'PATCHLEVEL'}) don't match\n"
	if $patchlevel != $Config{'PATCHLEVEL'};

# Fetch some frequently-used items from %Config
$installbin = $Config{installbin};
$installscript = $Config{installscript};
$installprivlib = $Config{installprivlib};
$installarchlib = $Config{installarchlib};
$installsitelib = $Config{installsitelib};
$installsitearch = $Config{installsitearch};
$installman1dir = $Config{installman1dir};
$man1ext = $Config{man1ext};
# Did we build libperl as a shared library?
$d_shrplib = $Config{d_shrplib};
$shrpdir = $Config{shrpdir};
# Shared library and dynamic loading suffixes.
$so = $Config{so};
$dlext = $Config{dlext};

$d_dosuid = $Config{d_dosuid};
$binexp = $Config{binexp};

# Do some quick sanity checks.

if ($d_dosuid && $>) { die "You must run as root to install suidperl\n"; }

   $installbin		|| die "No installbin directory in config.sh\n";
-d $installbin		|| mkpath($installbin, 1, 0777);
-d $installbin		|| die "$installbin is not a directory\n";
-w $installbin		|| die "$installbin is not writable by you\n"
	unless $installbin =~ m#^/afs/# || $nonono;

-x 'perl' . $exe_ext	|| die "perl isn't executable!\n";
-x 'suidperl' . $exe_ext|| die "suidperl isn't executable!\n" if $d_dosuid;

-x 't/TEST'		|| warn "WARNING: You've never run 'make test'!!!",
	"  (Installing anyway.)\n";

if ($d_shrplib) {
    if (!<libperl*.$so*>) {
	warn "WARNING: Can't find libperl*.$so* to install into $shrpdir.",
	    "  (Installing other things anyway.)\n";
    } else {
	mkpath($shrpdir, 1, 0777);
	-w $shrpdir	|| $nonono || die "$shrpdir is not writable by you\n";
	&cmd("cp libperl*.$so* $shrpdir");
    }
}

# First we install the version-numbered executables.

&safe_unlink("$installbin/perl$ver$exe_ext");
&cmd("cp perl$exe_ext $installbin/perl$ver$exe_ext");

&safe_unlink("$installbin/sperl$ver$exe_ext");
if ($d_dosuid) {
    &cmd("cp suidperl$exe_ext $installbin/sperl$ver$exe_ext");
    &chmod(04711, "$installbin/sperl$ver$exe_ext");
}

exit 0 if $versiononly;

# Make links to ordinary names if installbin directory isn't current directory.

if (! &samepath($installbin, '.')) {
    &safe_unlink("$installbin/perl$exe_ext", "$installbin/suidperl$exe_ext");
    &link("$installbin/perl$ver$exe_ext", "$installbin/perl$exe_ext");
    &link("$installbin/sperl$ver$exe_ext", "$installbin/suidperl$exe_ext") 
      if $d_dosuid;
}

if (! &samepath($installbin, 'x2p')) {
    &safe_unlink("$installbin/a2p$exe_ext");
    &cmd("cp x2p/a2p$exe_ext $installbin/a2p$exe_ext");
    &chmod(0755, "$installbin/a2p$exe_ext");
}

# Install scripts.

mkpath($installscript, 1, 0777);

for (@scripts) {
    if (-f $_) {   # cppstdin might not exist on this system.
	&cmd("cp $_ $installscript");
	s#.*/##; &chmod(0755, "$installscript/$_");
    }
}

# Install pod pages.  Where? I guess in $installprivlib/pod.
mkpath("${installprivlib}/pod", 1, 0777);
foreach $file (@pods) {
    # $file is a name like  pod/perl.pod
    cp_if_diff($file, "${installprivlib}/${file}");
}

# Install old man pages.

if ($installman1dir ne '') {
    mkpath($installman1dir, 1, 0777);

    if (! &samepath($installman1dir, '.')) {
	for (@manpages) {
	    ($new = $_) =~ s/man$/$man1ext/;
	    $new =~ s#.*/##;
	    print STDERR "  Installing $installman1dir/$new\n";
	    next if $nonono;
	    open(MI,$_) || warn "Can't open $_: $!\n";
	    open(MO,">$installman1dir/$new") || 
		    warn "Can't install $installman1dir/$new: $!\n";
	    print MO ".ds RP Release $release Patchlevel $patchlevel\n";
	    while (<MI>) {
		print MO;
	    }
	    close MI;
	    close MO;
	}
    }
}

# Install library files.

$do_installarchlib = $do_installprivlib = 0;
    
mkpath($installprivlib, 1, 0777);
mkpath($installarchlib, 1, 0777);
mkpath($installsitelib, 1, 0777) if ($installsitelib);
mkpath($installsitearch, 1, 0777) if ($installsitearch);

if (chdir "lib") {
    $do_installarchlib = ! &samepath($installarchlib, '.');
    $do_installprivlib = ! &samepath($installprivlib, '.');

    if ($do_installarchlib || $do_installprivlib) {
	find(\&installlib, '.');
    }
    chdir ".." || die "Can't cd back to source directory: $!\n";
}
else {
    warn "Can't cd to lib to install lib files: $!\n";
}

# Install header files and libraries.
mkpath("$installarchlib/CORE", 1, 0777);
foreach $file (<*.h libperl*.*>) {
    cp_if_diff($file,"$installarchlib/CORE/$file");
    &chmod(0444,"$installarchlib/CORE/$file");
}
# AIX needs perl.exp installed as well.
cp_if_diff("perl.exp" ,"$installarchlib/CORE/perl.exp") if ($^O eq 'aix');

# If they have built sperl.o...
cp_if_diff("sperl.o" ,"$installarchlib/CORE/sperl.o") if (-f 'sperl.o');


# Offer to install perl in a "standard" location

$mainperl_is_instperl = 0;

if (-w $mainperldir && ! &samepath($mainperldir, $installbin) && !$nonono) {
    # First make sure $mainperldir/perl is not already the same as
    # the perl we just installed
    if (-x "$mainperldir/perl$exe_ext") {
	# Try to be clever about mainperl being a symbolic link
	# to binexp/perl if binexp and installbin are different.
	$mainperl_is_instperl =
	    &samepath("$mainperldir/perl$exe_ext", "$installbin/perl$exe_ext") ||
	     (($binexp ne $installbin) &&
	      (-l "$mainperldir/perl$exe_ext") &&
	      ((readlink "$mainperldir/perl$exe_ext") eq "$binexp/perl$exe_ext"));
    }
    if ((! $mainperl_is_instperl) &&
	(&yn("Many scripts expect perl to be installed as " .
	     "$mainperldir/perl.\n" . 
	     "Do you wish to have $mainperldir/perl be the same as\n" .
	     "$binexp/perl? [y] ")))
    {	
	unlink("$mainperldir/perl$exe_ext");
	eval 'link("$installbin/perl$exe_ext", "$mainperldir/perl$exe_ext")' ||
	eval 'symlink("$binexp/perl$exe_ext", "$mainperldir/perl$exe_ext")' ||
	&cmd("cp $installbin/perl$exe_ext $mainperldir$exe_ext");
	$mainperl_is_instperl = 1;
    }
}

# Check to make sure there aren't other perls around in installer's
# path.  This is probably UNIX-specific.  Check all absolute directories
# in the path except for where public executables are supposed to live.
# Also skip $mainperl if the user opted to have it be a link to the
# installed perl.

$dirsep = ($^O eq 'os2') ? ';' : ':' ;
($path = $ENV{"PATH"}) =~ s:\\:/:g ;
@path = split(/$dirsep/, $path);
@otherperls = ();
for (@path) {
    next unless m,^/,;
    next if ($_ eq $binexp);
    # Use &samepath here because some systems have other dirs linked
    # to $mainperldir (like SunOS)
    next if ($mainperl_is_instperl && &samepath($_, $mainperldir));
    push(@otherperls, "$_/perl$exe_ext")
      if (-x "$_/perl$exe_ext" && ! -d "$_/perl$exe_ext");
}
if (@otherperls) {
    print STDERR "\nWarning: perl appears in your path in the following " .
	"locations beyond where\nwe just installed it:\n";
    for (@otherperls) {
	print STDERR "    ", $_, "\n";
    }
    print STDERR "\n";
}

print STDERR "  Installation complete\n";

exit 0;

###############################################################################

sub yn {
    local($prompt) = @_;
    local($answer);
    local($default) = $prompt =~ m/\[([yn])\]\s*$/i;
    print STDERR $prompt;
    chop($answer = <STDIN>);
    $answer = $default if $answer =~ m/^\s*$/;
    ($answer =~ m/^[yY]/);
}

sub unlink {
    local(@names) = @_;
    my($cnt) = 0;

    foreach $name (@names) {
	next unless -e $name;
	chmod 0777, $name if $^O eq 'os2';
	print STDERR "  unlink $name\n";
	( CORE::unlink($name) and ++$cnt 
	  or warn "Couldn't unlink $name: $!\n" ) unless $nonono;
    }
    return $cnt;
}

sub safe_unlink {
    local(@names) = @_;

    foreach $name (@names) {
	next unless -e $name;
	next if $nonono;
	chmod 0777, $name if $^O eq 'os2';
	print STDERR "  unlink $name\n";
	next if CORE::unlink($name);
	warn "Couldn't unlink $name: $!\n";
	if ($! =~ /busy/i) {
	    print STDERR "  mv $name $name.old\n";
	    &rename($name, "$name.old") || warn "Couldn't rename $name: $!\n";
	}
    }
}

sub cmd {
    local($cmd) = @_;
    print STDERR "  $cmd\n";
    unless ($nonono) {
	system $cmd;
	warn "Command failed!!!\n" if $?;
    }
}

sub rename {
    local($from,$to) = @_;
    if (-f $to and not unlink($to)) {
	my($i);
	for ($i = 1; $i < 50; $i++) {
	    last if CORE::rename($to, "$to.$i");
	}
	warn("Cannot rename to `$to.$i': $!"), return 0 
	   if $i >= 50;	# Give up!
    }
    link($from,$to) || return 0;
    unlink($from);
}

sub link {
    local($from,$to) = @_;

    print STDERR "  ln $from $to\n";
    eval {
      CORE::link($from,$to) || warn "Couldn't link $from to $to: $!\n" unless $nonono;
    };
    if ($@) {
      system( $cp, $from, $to )
	&& warn "Couldn't copy $from to $to: $!\n" unless $nonono;
    }
}

sub chmod {
    local($mode,$name) = @_;

    printf STDERR "  chmod %o %s\n", $mode, $name;
    CORE::chmod($mode,$name) || warn sprintf("Couldn't chmod %o %s: $!\n",$mode,$name)
	unless $nonono;
}

sub samepath {
    local($p1, $p2) = @_;
    local($dev1, $ino1, $dev2, $ino2);

    if ($p1 ne $p2) {
	($dev1, $ino1) = stat($p1);
	($dev2, $ino2) = stat($p2);
	($dev1 == $dev2 && $ino1 == $ino2);
    }
    else {
	1;
    }
}

sub installlib {
    my $dir = $File::Find::dir;
    $dir =~ s#^\.(?![^/])/?##;

    my $name = $_;
    
    # ignore patch backups and the .exists files.
    return if $name =~ m{\.orig$|~$|^\.exists};

    $name = "$dir/$name" if $dir ne '';

    my $installlib = $installprivlib;
    if ((substr($dir, 0, 4) eq 'auto') || ($name eq 'Config.pm')) {
        $installlib = $installarchlib;
	return unless $do_installarchlib;
    } else {
	return unless $do_installprivlib;
    }

    if (-f $_) {
	if (/\.al$/ || /\.ix$/) {
	    $installlib = $installprivlib;
	    #We're installing *.al and *.ix files into $installprivlib,
	    #but we have to delete old *.al and *.ix files from the 5.000
	    #distribution:
	    #This might not work because $archname might have changed.
	    &unlink("$installarchlib/$name");
	}
	system "cmp", "-s", $_, "$installlib/$name";
	if ($?) {
	    &unlink("$installlib/$name");
	    mkpath("$installlib/$dir", 1, 0777);
	    cp_if_diff($_, "$installlib/$name");
	    # HP-UX (at least) needs to maintain execute permissions
	    # on dynamically-loaded libraries.
	    if ($name =~ /\.(so|$dlext)$/o) {
		&chmod(0555, "$installlib/$name");
	    }
	    else {
		&chmod(0444, "$installlib/$name");
	    }
	}
    } elsif (-d $_) {
	mkpath("$installlib/$name", 1, 0777);
    }
}

# Copy $from to $to, only if $from is different than $to.
# Also preserve modification times for .a libraries.
# On some systems, if you do
#   ranlib libperl.a
#   cp libperl.a /usr/local/lib/perl5/archlib/CORE/libperl.a
# and then try to link against the installed libperl.a, you might
# get an error message to the effect that the symbol table is older
# than the library.
sub cp_if_diff {
    my($from,$to)=@_;
    -f $from || die "$0: $from not found";
    system "cmp", "-s", $from, $to;
    if ($?) {
	my ($atime, $mtime);
	unlink($to);   # In case we don't have write permissions.
	cmd("cp $from $to");
	# Restore timestamps if it's a .a library.
	if ($to =~ /\.a$/) {
	    ($atime, $mtime) = (stat $from)[8,9];
	    utime $atime, $mtime, $to;
	}
    }
}
