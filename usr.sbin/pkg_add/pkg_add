#! /usr/bin/perl

# ex:ts=8 sw=4:
# $OpenBSD: pkg_add,v 1.78 2004/10/17 09:32:21 espie Exp $
#
# Copyright (c) 2003-2004 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# this is it ! The hard one
use strict;
use warnings;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::PackageLocator;
use OpenBSD::PackageName;
use OpenBSD::PkgCfl;
use OpenBSD::PkgSpec;
use OpenBSD::Vstat;
use Getopt::Std;
use OpenBSD::Error;
use File::Copy;

our %forced = ();
our ($ftp_only, $cdrom_only);

sub ensure_ldconfig
{
	my $state = shift;
	return if $state->{not};
	return if $state->{do_faked};
	return unless defined $OpenBSD::PackingElement::Lib::todo;
	VSystem($state->{verbose}, 
	    @OpenBSD::PackingElement::Lib::ldconfig, "-m", 
	    keys %$OpenBSD::PackingElement::Lib::todo);
	undef $OpenBSD::PackingElement::Lib::todo;
}

# used by newuser/newgroup to deal with options.
sub add_entry
{
	my ($l, $f, $v) = @_;
	return if !defined $v or $v eq '';
	if ($v =~ m/^\!/) {
		push(@$l, $f, $');
	} else {
		push(@$l, $f, $v);
	}
}

package OpenBSD::PackingElement;
use OpenBSD::Error;

my ($uidcache, $gidcache);

sub install
{
}

sub set_modes
{
	my ($self, $name) = @_;

	if (defined $self->{owner} || defined $self->{group}) {
		require OpenBSD::IdCache;

		if (!defined $uidcache) {
			$uidcache = OpenBSD::UidCache->new();
			$gidcache = OpenBSD::GidCache->new();
		}
		my ($uid, $gid) = (stat $name)[4,5];
		if (defined $self->{owner}) {
			$uid = $uidcache->lookup($self->{owner}, $uid);
		}
		if (defined $self->{group}) {
			$gid = $gidcache->lookup($self->{group}, $gid);
		}
		chown $uid, $gid, $name;
	}
	if (defined $self->{mode}) {
		my $v = $self->{mode};
		if ($v =~ m/^\d+$/) {
			chmod oct($v), $name;
		} else {
			System('chmod', $self->{mode}, $name);
		}
	}
}

package OpenBSD::PackingElement::NewUser;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @_;
	my $user = $self->{name};
	print "adding user $user\n" if $state->{verbose};
	return if $state->{not};
	my $ok = $self->check();
	if (defined $ok) {
		if ($ok == 0) {
			Fatal "user $user does not match\n";
		}
	} else {
		my $l=[];
		push(@$l, "-v") if $state->{verbose};
		main::add_entry($l, '-u', $self->{uid});
		main::add_entry($l, '-g', $self->{group});
		main::add_entry($l, '-L', $self->{class});
		main::add_entry($l, '-c', $self->{comment});
		main::add_entry($l, '-d', $self->{home});
		main::add_entry($l, '-s', $self->{shell});
		VSystem($state->{verbose}, '/usr/sbin/useradd', @$l, $user);
	}
}

package OpenBSD::PackingElement::NewGroup;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @_;
	my $group = $self->{name};
	print "adding group $group\n" if $state->{verbose};
	return if $state->{not};
	my $ok = $self->check();
	if (defined $ok) {
		if ($ok == 0) {
			Fatal "group $group does not match\n";
		}
	} else {
		my $l=[];
		push(@$l, "-v") if $state->{verbose};
		main::add_entry($l, '-g', $self->{gid});
		VSystem($state->{verbose}, '/usr/sbin/groupadd', @$l, $group);
	}
}

package OpenBSD::PackingElement::Sysctl;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @_;

	my $name = $self->{name};
	open(my $pipe, '-|', '/sbin/sysctl', $name);
	my $actual = <$pipe>;
	chomp $actual;
	$actual =~ s/^\Q$name\E\s*\=\s*//;
	if ($self->{mode} eq '=' && $actual eq $self->{value}) {
		return;
	}
	if ($self->{mode} eq '>=' && $actual >= $self->{value}) {
		return;
	}
	if ($state->{not}) {
		print "sysctl -w $name != ".
		    $self->{value}, "\n";
		return;
	}
	VSystem($state->{verbose}, '/sbin/sysctl', $name.'='.$self->{value});
}
			
package OpenBSD::PackingElement::FileBase;
use OpenBSD::Error;
use File::Basename;
use File::Path;

sub install
{
	my ($self, $state) = @_;
	my $fullname = $self->fullname();

	my $file=$state->{archive}->next();
	if ($file->{name} ne $self->{name}) {
		Fatal "Error: archive does not match", $file->{name}, "!=",
		$self->{name}, "\n";
	}
	my $destdir = $state->{destdir};

	print "extracting $destdir$fullname\n" if $state->{verbose};
	return if $state->{not};
	$file->{name} = $fullname;
	$file->{cwd} = $self->{cwd};
	$file->{destdir} = $destdir;
	# faked installation are VERY weird
	if (defined $self->{symlink} && $state->{do_faked}) {
		$file->{linkname} = $destdir.$file->{linkname};
	}
	$file->create();
	$self->set_modes($destdir.$fullname);
}

package OpenBSD::PackingElement::EndFake;
sub install
{
	my ($self, $state) = @_;

	$state->{end_faked} = 1;
}

package OpenBSD::PackingElement::Sample;
use OpenBSD::Error;
use File::Copy;

sub install
{
	my ($self, $state) = @_;

	my $destdir = $state->{destdir};
	my $filename = $destdir.$self->fullname();
	my $orig = $self->{copyfrom};
	if (!defined $orig) {
		Fatal "\@sample element does not reference a valid file\n";
	}
	my $origname = $destdir.$orig->fullname();
	if (-e $filename) {
		print "The existing file $filename has NOT been changed\n";
		if (defined $orig->{md5}) {
			require OpenBSD::md5;

			my $md5 = OpenBSD::md5::fromfile($filename);
			if ($md5 eq $orig->{md5}) {
				print "\t(but it seems to match the sample file $origname)\n";
			} else {
				print "\tIt does not match the sample file $origname\n";
				print "You may wish to update it manually\n";
			}
		}
	} else {
		if ($state->{not}) {
			print "The file $filename would be installed from $origname\n";
		} else {
			if (!copy($origname, $filename)) {
				Warn "File $filename could not be installed:\n\t$!\n";
			}
			$self->set_modes($filename);
			print "The file $filename has been installed from $origname\n";
		}
	}
}

package OpenBSD::PackingElement::Sampledir;

sub install
{
	&OpenBSD::PackingElement::Dir::install;
}

package OpenBSD::PackingElement::Mandir;

sub install
{
	my ($self, $state) = @_;
	$self->SUPER::install($state);
	print "You may wish to add ", $self->fullname(), " to /etc/man.conf\n";
}

package OpenBSD::PackingElement::Manpage;

sub install
{
	my ($self, $state) = @_;
	$self->SUPER::install($state);
	$self->register_manpage($state) unless $state->{not};
}

package OpenBSD::PackingElement::InfoFile;
use File::Basename;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @_;
	$self->SUPER::install($state);
	return if $state->{not};
	my $fullname = $state->{destdir}.$self->fullname();
	VSystem($state->{verbose}, 
	    "install-info", "--info-dir=".dirname($fullname), $fullname);
}

package OpenBSD::PackingElement::Shell;
sub install
{
	my ($self, $state) = @_;
	$self->SUPER::install($state);
	return if $state->{not};
	my $fullname = $self->fullname();
	my $destdir = $state->{destdir};
	# go append to /etc/shells if needed
	open(my $shells, '<', $destdir.'/etc/shells') or return;
	local $_;
	while(<$shells>) {
		s/^\#.*//;
		return if $_ =~ m/^\Q$fullname\E\s*$/;
	}
	close($shells);
	open(my $shells2, '>>', $destdir.'/etc/shells') or return;
	print $shells2 $fullname, "\n";
	close $shells2;
	print "Shell $fullname appended to $destdir/etc/shells\n";
}

package OpenBSD::PackingElement::Dir;
sub install
{
	my ($self, $state) = @_;
	my $fullname = $self->fullname();
	my $destdir = $state->{destdir};

	print "new directory ", $destdir, $fullname, "\n" if $state->{verbose};
	return if $state->{not};
	File::Path::mkpath($destdir.$fullname);
	$self->set_modes($destdir.$fullname);
}

package OpenBSD::PackingElement::Exec;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @_;

	$self->run($state);
}

package OpenBSD::PackingElement::Lib;

sub install
{
	my ($self, $state) = @_;
	$self->SUPER::install($state);
	return if $state->{do_faked};
	$self->mark_ldconfig_directory($state->{destdir});
}

package OpenBSD::PackingElement::Arch;

sub check
{
	my ($self, $forced_arch) = @_;

	my ($machine_arch, $arch);
	for my $ok (@{$self->{arches}}) {
		return 1 if $ok eq '*';
		if (defined $forced_arch) {
			if ($ok eq $forced_arch) {
				return 1;
			} else {
				next;
			}
		}
		if (!defined $machine_arch) {
			chomp($machine_arch = `/usr/bin/arch -s`);
		}
		return 1 if $ok eq $machine_arch;
		if (!defined $arch) {
			chomp($arch = `/usr/bin/uname -m`);
		}
		return 1 if $ok eq $arch;
	}
	return undef;
}

package main;

sub fill_conflict_lists
{
	my $state = shift;
	# first, find all possible potential conflicts
	for my $pkg (installed_packages()) {
		my $dir = installed_info($pkg);
		my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS, 
		    \&OpenBSD::PackingList::ConflictOnly);
		next unless defined $plist;
		$state->{conflict_list}->{$plist->pkgname()} = 
		    OpenBSD::PkgCfl->make_conflict_list($plist);
	}
}

my $errors = 0;

our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q);
getopts('avnIL:f:B:A:P:Q:');
if ($opt_f) {
	%forced = map {($_, 1)} split(/,/, $opt_f);
}
if ($opt_P) {
	if ($opt_P eq 'cdrom') {
		$cdrom_only = 1;
	}
	elsif ($opt_P eq 'ftp') { 
		$ftp_only = 1;
	}
	else {
	    Fatal "bad option: -P $opt_P";
	}
}

$opt_L = '/usr/local' unless defined $opt_L;

my $state = {};
$state->{cache} = {};
$state->{do_faked} = 0;
if (defined $opt_Q and defined $opt_B) {
	Fatal "-Q and -B are incompatible options";
}
if (defined $opt_Q) {
	$state->{destdir} = $opt_Q;
	$state->{do_faked} = 1;
} elsif (defined $opt_B) {
	$state->{destdir} = $opt_B;
} elsif (defined $ENV{'PKG_PREFIX'}) {
	$state->{destdir} = $ENV{'PKG_PREFIX'};
}
if (defined $state->{destdir}) {
	$state->{destdir}.='/';
	$ENV{'PKG_DESTDIR'} = $state->{destdir};
} else {
	$state->{destdir} = '';
}

if ($< && !$forced{nonroot}) {
	Fatal "$0 must be run as root";
}

$state->{conflict_list} = {};
$state->{not} = $opt_n;
$state->{dont_run_scripts} = $opt_I;
$state->{verbose} = $opt_v;
$state->{beverbose} = $opt_n || $opt_v;

fill_conflict_lists($state);

sub can_install($$)
{
	my ($pkgname, $state) = @_;

	if (is_installed $pkgname) {
		print "package $pkgname is already installed\n";
		return undef unless $forced{installed};
	}

	while (my ($name, $l) = each %{$state->{conflict_list}}) {
		if ($l->conflicts_with($pkgname)) {
			print "package $pkgname conflicts with installed package $name\n";
			$errors++;
			return undef unless $forced{conflicts};
		}
	}

	return 1;
}


# This does pre_add a package: finding it and reading its package information
sub pre_add($$)
{
	my ($pkg, $state) = @_;
	my $pkgname1;
	my $operation = $state->{not} ? "Pretending to add" : "Adding";
	
	if ($pkg ne '-') {
		my $more = "";
		if ($state->{do_faked}) {
			$more = " under ".$state->{destdir};
		}

		print "$operation $pkg$more\n";
		$pkgname1 = OpenBSD::PackageName::url2pkgname($pkg);
		return undef unless can_install($pkgname1, $state);
	}

	my $handle = OpenBSD::PackageLocator->find($pkg);
	if (!$handle) {
		print "Can't find $pkg\n";
		$errors++;
		return undef;
	}
	my $dir = $handle->info();
    	my $plist = $handle->{plist} = 
	    OpenBSD::PackingList->fromfile($dir.CONTENTS);
	unless (defined $plist) {
		print "Can't find CONTENTS from $pkg\n";
		$errors++;
		return undef;
	}
	if ($plist->pkgbase() ne $opt_L) {
		print "Localbase mismatch: package has: ", $plist->pkgbase(), " , user wants: $opt_L\n";
		$errors++;
		return undef;
	}
	my $pkgname = $plist->pkgname();
	if (defined $pkgname1) {
		if ($pkgname ne $pkgname1) {
			print "Package name is not consistent ???\n";
			$errors++;
			return undef;
		}
	} else {
		my $modifier = "";
		if ($state->{do_faked}) {
			$modifier = " under ".$state->{destdir};
		}
			
		print "$operation $pkgname$modifier\n";
		return undef unless can_install($pkgname, $state);
	}
	# second handling of conflicts
	my $l = OpenBSD::PkgCfl->make_conflict_list($plist);
	$handle->{conflicts} = $l;
	if ($l->conflicts_with(installed_packages())) {
		print "package $pkg has conflicts: ", 
		    join(' ', $l->conflicts_with(installed_packages())), "\n";
		$errors++;
		return undef unless $forced{conflicts};
	}
	return $handle;
}


sub solve_dependencies
{
	my ($handle, @extra) = @_;
	my $plist = $handle->{plist};
	my $to_register = $handle->{solved_dependencies} = [];
	my $to_install;

	# do simple old style pkgdep first
	my @deps = ();
	for my $dep (@{$plist->{pkgdep}}) {
		if (!is_installed($dep->{name})) {
			push(@deps, $dep->{name});
		}
		push(@$to_register, $dep->{name});
	}
	for my $dep (@{$plist->{newdepend}}, @{$plist->{libdepend}}) {
	    next if defined $dep->{name} and $dep->{name} ne $plist->pkgname();
	    my @candidates = OpenBSD::PkgSpec::match($dep->{pattern}, installed_packages());
	    if (@candidates >= 1) {
		    push(@$to_register, $candidates[0]);
	    } else {
	    	if (!defined $to_install) {
			$to_install = {};
			for my $fullname (@extra) {
			    $to_install->{OpenBSD::PackageName::url2pkgname($fullname)} = $fullname;
			}
		}
	    	# try against list of packages to install
	    	my @candidates = OpenBSD::PkgSpec::match($dep->{pattern}, keys %{$to_install});
		if (@candidates >= 1) {
		    push(@deps, $to_install->{$candidates[0]});
		    push(@$to_register, $candidates[0]);
		} else {
		    # try with list of packages
		    my @candidates = OpenBSD::PkgSpec::match($dep->{pattern}, OpenBSD::PackageLocator::available());
		    # one single choice
		    if (@candidates == 1) {
			push(@deps, $candidates[0]);
			push(@$to_register, $candidates[0]);
		    } elsif (@candidates > 1) {
			# grab default if available
		    	if (grep {$_ eq $dep->{def}} @candidates) {
			    push(@deps, $dep->{def});
			    push(@$to_register, $dep->{def});
			# grab first one otherwise
			} else {
			    push(@deps, $candidates[0]);
			    push(@$to_register, $candidates[0]);
			}
		    } else {
			# can't get a list of packages, assume default
			# will be there.
			push(@deps, $dep->{def});
			push(@$to_register, $dep->{def});
		    }
		}
	    }
	}

	if (@{$to_register} > 0) {
	    print "Dependencies for ", $plist->pkgname(), " resolve to: ", 
	    	join(',', @$to_register);
	    print " (todo: ", join(',', @deps), ")" if @deps > 0;
	    print "\n";
	}
	return @deps;
}

sub register_installation
{
	my ($dir, $dest, $plist) = @_;
	mkdir($dest);
	for my $i (info_names()) {
		copy($dir.$i, $dest);
	}
	$plist->tofile($dest.CONTENTS);
}

sub borked_installation
{
	my ($plist, $dir) = @_;

	use OpenBSD::PackingElement;

	my $borked = borked_package();
	# fix packing list for pkg_delete
	$plist->{items} = $plist->{done};

	# last file may have not copied correctly
	my $last = $plist->{items}->[@{$plist->{items}}-1];
	if ($last->IsFile()) {
	    require OpenBSD::md5;

	    my $old = $last->{md5};
	    $last->{md5} = OpenBSD::md5::fromfile($last->{fullname});
	    if ($old ne $last->{md5}) {
		print "Adjusting md5 for ", $last->{fullname}, " from ",
		    $old, " to ", $last->{md5}, "\n";
	    }
	}
	OpenBSD::PackingElement::Cwd->add($plist, '.');
	my $pkgname = $plist->pkgname();
	$plist->{name}->{name} = $borked;
	$plist->{pkgdep} = [];
	my $dest = installed_info($borked);
	register_installation($dir, $dest, $plist);
	Fatal "Installation of $pkgname failed, partial installation recorded as $borked";
}

sub check_lib_specs
{
	my $base = shift;
	my $dir;
	for my $spec (split(/,/, shift)) {
		print "checking libspec $spec " if $opt_v;
		if ($spec =~ m|.*/|) {
			$dir = "$base/$&";
			$spec = $';
		} else {
			$dir = "$base/lib";
		}
		if ($spec =~ m/^(.*)\.(\d+)\.(\d+)$/) {
			my ($libname, $major, $minor) = ($1, $2, $3);
			my @candidates = 
			    grep { /^lib\Q$libname\E\.so\.$major\.(\d+)$/ 
			    	&& $1 >= $minor } 
			    OpenBSD::Vstat::vreaddir($dir);
			if (@candidates == 0) {
				print "not found\n" if $opt_v;
				return undef;
			} else {
			    print "found ", $candidates[0], "\n" if $opt_v;
			}
		} else {
			print "bad spec\n" if $opt_v;
			return undef;
		}
	}
	return 1;
}

sub collision_report($)
{
	my $list = shift;
	my %todo = map {($_, 1)} @$list;
	my $bypkg = {};
	

	for my $pkg (installed_packages()) {
		my $plist = OpenBSD::PackingList->fromfile(installed_info($pkg).CONTENTS, \&OpenBSD::PackingList::FilesOnly);
		for my $item (@{$plist->{items}}) {
			next unless $item->IsFile();
			my $name = $item->fullname();
			if (defined $todo{$name}) {
				$bypkg->{$pkg} = [] unless defined $bypkg->{$pkg};
				push(@{$bypkg->{$pkg}}, $name);
				delete $todo{$name};
			}
		}
	}
	print "Collision: the following files already exist\n";
	for my $pkg (sort keys %$bypkg) {
	    for my $item (sort @{$bypkg->{$pkg}}) {
	    	print "\t$item ($pkg)\n";
	    }
	}
	for my $item (sort keys %todo) {
	    print "\t$item\n";
	}
}

sub validate_plist($$)
{
	my ($plist, $destdir) = @_;

	my $problems = 0;
	my $pkgname = $plist->pkgname();

	my $extra = $plist->{extrainfo};
	if ($cdrom_only && ((!defined $extra) || $extra->{cdrom} ne 'yes')) {
	    Warn "Package $pkgname is not for cdrom.\n";
	    $problems++;
	}
	if ($ftp_only && ((!defined $extra) || $extra->{ftp} ne 'yes')) {
	    Warn "Package $pkgname is not for ftp.\n";
	    $problems++;
	}

	# check for collisions with existing stuff
	my $colliding = [];
	for my $item (@{$plist->{items}}) {
		next unless $item->IsFile();
		my $fname = $destdir.$item->fullname();
		if (OpenBSD::Vstat::vexists($fname)) {
			push(@$colliding, $fname);
			$problems++;
		}
		my $s = OpenBSD::Vstat::add($fname, $item->{size});
		next unless defined $s;
		if ($s->{ro}) {
			Warn "Error: ", $s->{mnt}, " is read-only ($fname)\n";
			$problems++;
		}
		if ($s->avail() < 0) {
			Warn "Error: ", $s->{mnt}, " is not large enough ($fname)\n";
			$problems++;
		}
	}
	if (@$colliding > 0) {
		collision_report($colliding);
	}
	Fatal "fatal issues" if $problems;
}

sub do_script
{
	my ($plist, $name, $state, $args) = @_;
	return unless $plist->has($name);
	$plist->get($name)->run($state, $args);
}

sub manpages_index
{
	my ($state) = @_;
	return unless defined $state->{mandirs};
	my $destdir = $state->{destdir};
	require OpenBSD::Makewhatis;

	while (my ($k, $v) = each %{$state->{mandirs}}) {
		my @l = map { $destdir.$_ } @$v;
		eval { OpenBSD::Makewhatis::merge($destdir.$k, \@l); };
		if ($@) {
			print STDERR "Error in makewhatis: $@\n";
		}
	}
}


sub really_add($$)
{
	my ($handle, $state) = @_;
	my $destdir = $state->{destdir};
	my $verbose = $state->{verbose};
	my $not = $state->{not};
	my $plist = $handle->{plist};
	my $dir = $handle->info();
	my $pkgname = $plist->pkgname();
	$state->{archive} = $handle;
	$state->{dir} = $dir;
	$state->{pkgname} = $pkgname;

	validate_plist($plist, $destdir) unless $state->{do_faked};

	if (!defined $handle) {
		Fatal "Archive in $pkgname broken";
	}

	$ENV{'PKG_PREFIX'} = $plist->pkgbase();

	my $interrupted;
	local $SIG{'INT'} = sub {
		$interrupted = 1;
	};

	do_script($plist, REQUIRE, $state, "INSTALL");

	do_script($plist, INSTALL, $state, "PRE-INSTALL");

	$plist->{done} = [];
	$state->{end_faked} = 0;
	for my $item (@{$plist->{groups}}, @{$plist->{users}}, @{$plist->{items}}) {
		eval { $item->install($state); };
		if ($@) {
			Warn $@;
			$errors++;
			last;
		}
		push(@{$plist->{done}}, $item);
		last if $interrupted;
		# stop faked installation there...
		if ($state->{do_faked} && $state->{end_faked}) {
			last;
		}
	}

	$handle->close();

	if (!$interrupted) {
		eval { do_script($plist, INSTALL, $state, "POST-INSTALL") };
		if ($@) {
			Warn $@;
			$errors++;
		}
	}

	unlink($dir.CONTENTS);
	if (!$not) {
		if ($interrupted || $errors) {
			borked_installation($plist, $dir);
		}
		my $dest = installed_info($pkgname);
		register_installation($dir, $dest, $plist);
		if (defined $handle->{solved_dependencies}) {
			require OpenBSD::RequiredBy;

			for my $dep (@{$handle->{solved_dependencies}}) {
				OpenBSD::RequiredBy->new($dep)->add($pkgname);
			}
		}
	}
	add_installed($pkgname);
	if ($plist->has(DISPLAY)) {
		$plist->get(DISPLAY)->prepare($state);
	}
}


sub install_package
{
	my ($pkg, $state, @todo) = @_;
	my $cache = $state->{cache};

	if (!defined $cache->{$pkg}) {
		$cache->{$pkg} = pre_add($pkg, $state);
	}

	my $handle = $cache->{$pkg};
	if ($errors > 0) {
		Fatal "Fatal error" unless defined $handle;
	} else {
		return () unless defined $handle;
	}

	my $plist = $handle->{plist};

	if (is_installed($plist->pkgname())) {
		$handle->close();
		return ();
	}
	if ($plist->has('arch')) {
		unless ($plist->{arch}->check($opt_A)) {
			print "$pkg is not for the right architecture\n";
			return () unless $forced{arch};
		}
	}
	if (!defined $handle->{solved_dependencies}) {
		my @deps = solve_dependencies($handle, @todo);
		if (@deps > 0) {
			return (@deps, $pkg);
		}
	}

	# verify dependencies and register them

	for my $dep (@{$handle->{solved_dependencies}}) {
		next if is_installed($dep);
		print "Can't install $pkg: can't resolve $dep\n";
		return ();
	}
	for my $dep (@{$plist->{libdepend}}) {
		# can't check libspecs yet
		return () if defined $dep->{name} and $dep->{name} ne $plist->pkgname();
		if (!check_lib_specs($plist->pkgbase(), $dep->{libspec})) {
			Warn "Can't install $pkg: incorrect libspec: ",
			    $dep->{libspec}, "\n";
			return () unless $forced{libdepends};
		}
	}
	for my $dep (@{$handle->{solved_dependencies}}) {
		OpenBSD::PackingElement::PkgDep->add($plist, $dep);
	}
	really_add($handle, $state);
	$state->{conflict_list}->{$plist->pkgname()} = $handle->{conflicts};
	return ();
}

my @todo = (@ARGV);

eval {
while (my $pkg = shift @todo) {
	unshift(@todo, install_package($pkg, $state, @todo));
}
};

my $dielater = $@;

OpenBSD::PackingElement::Fontdir::finish_fontdirs();
manpages_index($state);
ensure_ldconfig($state);

if ($state->{beverbose}) {
	OpenBSD::Vstat::tally();
}
if (defined $state->{display}) {
	close $state->{display};
	my $pager = $ENV{'PAGER'} || "/usr/bin/more";
	System("$pager ".$state->{displayname});
}
if ($dielater) {
	die $dielater;
}
