#! /usr/bin/perl

# ex:ts=8 sw=4:
# $OpenBSD$
#
# Copyright (c) 2003-2009 Marc Espie <espie@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::AddDelete;

package OpenBSD::AddDelete;
use OpenBSD::Dependencies;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::PackageLocator;
use OpenBSD::PackageName;
use OpenBSD::PkgCfl;
use OpenBSD::Vstat;
use OpenBSD::Interactive;
use OpenBSD::Add;
use OpenBSD::SharedLibs;
use OpenBSD::UpdateSet;
use OpenBSD::Handle;

our ($state, %defines, $bad, $opt_B);

package OpenBSD::PackingList;

sub uses_old_libs
{
	my $plist = shift;
	require OpenBSD::RequiredBy;

	return  grep {/^\.libs\d*\-/o} 
	    OpenBSD::Requiring->new($plist->pkgname)->list;
}

sub has_new_sig
{
	my ($plist, $state) = @_;
	if (!defined $plist->{new_sig}) {
		my $n = OpenBSD::PackingList->from_installation($plist->pkgname)->signature;
		my $o = $plist->signature;
		$state->say("Comparing full signature for ", $plist->pkgname, " \"$o\" vs. \"$n\": ", $n eq $o ? "equal" : "different") 
		    if $state->{very_verbose};
		$plist->{new_sig} = $n ne $o;
	}
	return $plist->{new_sig};
}

package OpenBSD::pkg_add::State;
our @ISA=(qw(OpenBSD::UI));

# one-level dependencies tree, for nicer printouts
sub build_deptree
{
	my ($state, $set, @deps) = @_;

	if (defined $state->{deptree}->{$set}) {
		$set = $state->{deptree}->{$set};
	}
	for my $dep (@deps) {
		$state->{deptree}->{$dep} = $set unless
		    defined $state->{deptree}->{$dep};
	}
}

sub deptree_header
{
	my ($state, $pkg) = @_;
	if (defined $state->{deptree}->{$pkg}) {
		return $state->{deptree}->{$pkg}->shorter_print.':';
	} else {
		return '';
	}
}

sub set_name_from_handle
{
	my ($state, $h) = @_;
	$state->log->set_context($h->pkgname);
}

sub updater
{
	my $state = shift;
	if (!defined $state->{updater}) {
		require OpenBSD::Update;
		$state->{updater} = OpenBSD::Update->new;
	}
	return $state->{updater};
}

sub tracker
{
	my $state = shift;
	if (!defined $state->{tracker}) {
		require OpenBSD::Tracker;
		$state->{tracker} = OpenBSD::Tracker->new;
	}
	return $state->{tracker};
}

package OpenBSD::UpdateSet;
use OpenBSD::PackageInfo;
use OpenBSD::Error;

sub setup_header
{
	my ($set, $state, $handle, $info) = @_;

	my $header = $state->deptree_header($set);
	if (defined $handle) {
		$header .= $handle->pkgname;
	} else {
		$header .= $set->short_print;
	}
	if (defined $info) {
		$header.=" ($info)";
	}

	if (!$state->progress->set_header($header)) {
		if (!defined $info) {
			$header = "Adding $header";
		}
		if (defined $state->{lastheader} && 
		    $header eq $state->{lastheader}) {
			return;
		}
		$state->{lastheader} = $header;
		print $header;
		print "(pretending) " if $state->{not};
		if ($state->{do_faked}) {
			print " under ", $state->{destdir};
		}
		print "\n";
	}
}

sub complete
{
	my ($set, $state) = @_;

	for my $n ($set->newer) {
		$n->complete($state);
		return if $n->has_error;
	}

	return if defined $set->{installable};

	$set->{installable} = $set->can_install($state);

	if (!$set->{installable}) {
		for my $n ($set->newer) {
			$n->cleanup(OpenBSD::Handle::CANT_INSTALL);
 		}
	}
}

sub reorder_old
{
	my ($set, $state) = @_;
	# no need to sort things if there is one package to replace
	# return if $set->older <= 1;

	my $resolved;
	my @l = ();
	my %todo = map {($_->pkgname, $_)} $set->older;
	do {
		$resolved = 0;
BIGLOOP: 	while (my ($pkg, $h) = each %todo) {
			for my $name (OpenBSD::RequiredBy->new($pkg)->list) {
				next BIGLOOP if defined $todo{$name};
			}
			push(@l, $h);
			delete $todo{$pkg};
			$resolved++;
		}
	} while ($resolved);
	push(@l, values %todo);
	$set->{older} = \@l;
}

sub can_install
{
	my ($set, $state) = @_;
	for my $handle ($set->newer) {
		my $plist = $handle->plist;
		my $pkgname = $handle->pkgname;
		my @conflicts = OpenBSD::PkgCfl::find_all($plist, $state);
		next if @conflicts == 0;

		my %conflicts = map {($_,1)} @conflicts;
		@conflicts = keys %conflicts;

		if (!$state->{allow_replacing}) {
			if ($state->{defines}->{conflicts}) {
				$state->say("Forcing install of $pkgname in the presence of conflicts (",join(',', @conflicts), ")");
				return 1;
			}
			$state->say("Can't install $pkgname because of conflicts (",join(',', @conflicts), ")");
			$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
			return;
		}

		if (@conflicts >  5) {
			$state->say("Can't install $pkgname because of conflicts (",join(',', @conflicts), ")");
			$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
			return;
		}

		require OpenBSD::Replace;

		if (!OpenBSD::Replace::is_new_package_safe($plist, $state)) {
			$state->say("Can't safely update to $pkgname (use -F update to force it)");
			$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
			return;
		}

		for my $toreplace (@conflicts) {
			if ($state->tracker->is_installed($toreplace)) {
				$state->errsay("Cannot replace $toreplace with $pkgname: just got installed");
				$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
				return;
			}

			my $old_handle = OpenBSD::Handle->create_old($toreplace, $state);
			if ($old_handle->has_error(OpenBSD::Handle::NOT_FOUND)) {
				Fatal "Can't find $toreplace as an installed package\n";
			}
			if ($old_handle->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
				Fatal "Couldn't find packing-list for $toreplace\n";
			}

			if (!OpenBSD::Replace::can_old_package_be_replaced($old_handle->plist, 
			    $pkgname, $state, \%conflicts)) {
				$state->say("Can't update $toreplace into $pkgname");
				$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
				return;
			}
			$set->add_older($old_handle);

			if ($old_handle->plist->has('manual-installation') && 
			    !$plist->has('manual-installation')) {
				OpenBSD::PackingElement::ManualInstallation->add($plist);
			}
		}
		$set->{skipupdatedeps} = \%conflicts;
	}
	return 1;
}

package OpenBSD::AddDelete;

sub failed_message
{
	my ($base_msg, $interrupted, @l) = @_;
	my $msg = $base_msg;
	if ($interrupted) {
		$msg = "Caught SIG$interrupted. $msg";
	}
	if (@l > 0) {
		$msg.= ", partial installation recorded as ".join(',', @l);
	}
	return $msg;
}

sub save_partial_set
{
	my ($set, $state) = @_;

	return () if $state->{not};
	my @l = ();
	for my $h ($set->newer) {
		next unless defined $h->{partial};
		push(@l, OpenBSD::Add::record_partial_installation($h->plist, $state, $h->{partial}));
	}
	return @l;
}

sub partial_install
{
	my ($base_msg, $set, $state) = @_;
	return failed_message($base_msg, $state->{interrupted}, save_partial_set($set, $state));
}

sub really_add
{
	my ($set, $state) = @_;

	for my $h ($set->newer) {
		$h->plist->set_infodir($h->location->info);
	}

	$set->validate_plists($state);

	my $errors = 0;
	for my $handle ($set->newer) {
		$state->set_name_from_handle($handle);
		my $plist = $handle->plist;
		if ($plist->is_signed) {
			if ($state->{defines}->{nosig}) {
				$state->errsay("NOT CHECKING DIGITAL SIGNATURE FOR ",
				    $plist->pkgname);
				$state->{check_digest} = 0;
			} else {
				require OpenBSD::x509;

				if (!OpenBSD::x509::check_signature($plist, 
				    $state)) {
					Fatal "fatal issues in ", $set->print;
				}
				$state->{check_digest} = 1;
				$state->{packages_with_sig}++;
			}
		} else {
			$state->{packages_without_sig}{$plist->pkgname} = 1;
			$state->{check_digest} = 0;
		}
	}

	$set->setup_header($state);

	# XXX in `combined' updates, some dependencies may remove extra 
	# packages, so we do a double-take on the list of packages we 
	# are actually replacing.
	my $replacing = 0;
	if ($set->older_to_do) {
		$replacing = 1;
	} 
#	if (defined $plist->{old_libs}) {
#		$replacing = 1;
#	}
	$state->{replacing} = $replacing;

	$ENV{'PKG_PREFIX'} = $state->{localbase};

	my $handler = sub {
		$state->{interrupted} = shift;
	};
	local $SIG{'INT'} = $handler;
	local $SIG{'QUIT'} = $handler;
	local $SIG{'HUP'} = $handler;
	local $SIG{'KILL'} = $handler;
	local $SIG{'TERM'} = $handler;

	if ($replacing) {
		require OpenBSD::Replace;
		OpenBSD::Replace::save_old_libraries($set, $state);
	}

	$set->compute_size;

	if ($replacing) {
		for my $handle ($set->newer) {
			$set->setup_header($state, $handle, "extracting");

			try {
				OpenBSD::Replace::perform_extraction($handle, 
				    $state);
			} catchall {
				unless ($state->{interrupted}) {
					$state->errprint($_);
					$errors++;
				}
			};
			$state->progress->clear;
			if ($state->{interrupted} || $errors) {
				Fatal partial_install("Installation of ".
				    $handle->pkgname." failed", $set, $state);
			}
		}

		$set->{solver}->record_old_dependencies($state);
		for my $o ($set->older_to_do) {
			$set->setup_header($state, $o, "deleting");
			my $oldname = $o->pkgname;
			$state->set_name_from_handle($o);
			require OpenBSD::Delete;
			try {
			    OpenBSD::Delete::delete_plist($o->plist, $state);
			} catchall {
				$state->errprint($_);
				Fatal partial_install(
				    "Deinstallation of $oldname failed", 
				    $set, $state);
			};

			if (defined $state->{updatedepends}) {
				delete $state->{updatedepends}->{$oldname};
			}
			OpenBSD::PkgCfl::unregister($o->plist, $state);
			$state->progress->clear;
		}
		# Here there should be code to handle old libs
	}

	for my $handle ($set->newer) {
		my $pkgname = $handle->pkgname;
		my $header = $state->deptree_header($set).$pkgname;
		my $plist = $handle->plist;
		$set->setup_header($state, $handle,
		    $replacing ? "installing" : undef);
		$state->set_name_from_handle($handle);

		try {
			OpenBSD::Add::perform_installation($handle, $state);
			if (!$state->{interrupted} && $plist->has(INSTALL)) {
				$plist->get(INSTALL)->run($state, 'POST-INSTALL');
			}
		} catchall {
			unless ($state->{interrupted}) {
				$state->errprint($_);
				$errors++;
			}
		};
		$state->progress->next;

		unlink($plist->infodir.CONTENTS);
		if ($state->{interrupted} || $errors) {
			Fatal partial_install("Installation of $pkgname failed",
			    $set, $state);
		}
	}
	for my $handle ($set->newer) {
		my $pkgname = $handle->pkgname;
		my $plist = $handle->plist;
		OpenBSD::SharedLibs::add_libs_from_plist($plist);
		OpenBSD::Add::tweak_plist_status($plist, $state);
		$plist->to_cache;
		OpenBSD::Add::register_installation($plist);
		$set->{solver}->register_dependencies($state);
		add_installed($pkgname);
		delete $handle->{partial};
		OpenBSD::PkgCfl::register($plist, $state);
		if ($plist->has(DISPLAY)) {
			$plist->get(DISPLAY)->prepare($state);
		}
	}
	$set->{solver}->adjust_old_dependencies($state);
	if ($state->{repairdependencies}) {
		$set->{solver}->repair_dependencies($state);
	}
}

sub install_set
{
	my ($set, $state) = @_;

	if ($set->{finished}) {
		return ();
	}

	for my $handle ($set->newer) {
		if ($state->tracker->is_installed($handle->pkgname)) {
			$handle->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
			return ();
		}
	}

	$set->complete($state);

	for my $handle ($set->newer) {
		if ($handle->has_error(OpenBSD::Handle::ALREADY_INSTALLED)) {
			return ();
		}
		if ($handle->has_error) {
			$state->set_name_from_handle($handle);
			$state->log("Can't install ", $handle->pkgname, ":",
				$handle->error_message, "\n"); 
			$bad++;
			return ();
		}

		if ($handle->plist->has('arch')) {
			unless ($handle->plist->{arch}->check($state->{arch})) {
				$state->say($handle->pkgname, " is not for the right architecture");
				return () unless $defines{arch};
			}
		}
	}

	if (!defined $set->{solver}) {
		$set->{solver} = OpenBSD::Dependencies::Solver->new($set);
		my @deps = $set->{solver}->solve_depends($state);
		if ($state->{verbose}) {
			$set->{solver}->dump;
		}
		if (@deps > 0) {
			$state->build_deptree($set, @deps);
			return (@deps, $set);
		}
	}

	# verify dependencies have been installed
	my @baddeps = $set->{solver}->check_depends;

	if (@baddeps) {
		$state->errsay("Can't install ", $set->short_print,
		    ": can't resolve ", join(',', @baddeps));
		for my $handle ($set->newer) {
			$handle->location->close_now;
		}
		$bad++;
		return ();
	}

#	print "Didn't need to process: ", join(',', @{$set->{solver}->{todo}}), "\n";
	if (!$set->{solver}->solve_wantlibs($state)) {
		for my $handle ($set->newer) {
			$handle->location->close_now;
		}
		if (!$defines{libdepends}) {
			$bad++;
			return ();
		}
	}
#	if (!$set->{solver}->solve_tags($state)) {
#		$location->close_now;
#		if (!$defines{libdepends}) {
#			$bad++;
#			return ();
#		}
#	}
	really_add($set, $state);
	for my $handle ($set->newer) {
		$handle->cleanup;
	}
	$state->tracker->mark_installed($set);
	return ();
}

sub stem2location
{
	my ($repo, $name, $state) = @_;
	my $l = $repo->match_locations(OpenBSD::Search::Stem->new($name));
	if (@$l > 1 && !$state->{defines}->{allversions}) {
		$l = OpenBSD::Search::FilterLocation->keep_most_recent->filter_locations($l);
	}
	return $state->choose_location($name, $l);
}
 

sub find_truelocations
{
	my ($old, $new, $state) = @_;

	my $cache = {};
	for my $pkgname (@$old) {
		if (OpenBSD::PackageName::is_stem($pkgname)) {
			my ($h, $path, $repo);
			if ($pkgname =~ m/\//o) {
				($repo, $path, $pkgname) = OpenBSD::PackageLocator::path_parse($pkgname);
				$h = $repo;
			} else {
				$h = 'OpenBSD::PackageLocator';
				$path = "";
			}
			my $l = stem2location($h, $pkgname, $state);
			if (defined $l) {
				push(@$new, OpenBSD::UpdateSet->from_location($l));
 			} else {
 				$bad = 1;
			}
		} else {
			if (!defined $cache->{$pkgname}) {
				$cache->{$pkgname} = OpenBSD::UpdateSet->create_new($pkgname);
			}
			push(@$new, $cache->{$pkgname});
		}
	}
}

set_usage('pkg_add [-acIinqruvxz] [-A arch] [-B pkg-destdir] [-F keywords]',
'[-L localbase] [-l file] [-P type] [-Q quick-destdir] pkg-name [...]');

$state = OpenBSD::pkg_add::State->new;

our ($opt_a, $opt_A, $opt_P, $opt_Q, $opt_r, $opt_u, $opt_l, $opt_z);

handle_options('aqchruzl:A:P:Q:');

try {
$state->{cache} = {};
$state->{do_faked} = 0;
$state->{arch} = $opt_A;

if (defined $opt_Q and defined $opt_B) {
	Usage "-Q and -B are incompatible options";
}
if (defined $opt_Q and defined $opt_r) {
	Usage "-r and -Q are incompatible options";
}
if ($opt_P) {
	if ($opt_P eq 'cdrom') {
		$state->{cdrom_only} = 1;
	}
	elsif ($opt_P eq 'ftp') { 
		$state->{ftp_only} = 1;
	}
	else {
	    Usage "bad option: -P $opt_P";
	}
}
if (defined $opt_Q) {
	$state->{destdir} = $opt_Q;
	$state->{do_faked} = 1;
} elsif (defined $opt_B) {
	$state->{destdir} = $opt_B;
} elsif (defined $ENV{'PKG_PREFIX'}) {
	$state->{destdir} = $ENV{'PKG_PREFIX'};
}
if (defined $state->{destdir}) {
	$state->{destdir}.='/';
	$ENV{'PKG_DESTDIR'} = $state->{destdir};
} else {
	$state->{destdir} = '';
	delete $ENV{'PKG_DESTDIR'};
}


$state->{automatic} = $opt_a;
$state->{allow_replacing} = $opt_r || $opt_u;

if (@ARGV == 0 && !$opt_u && !$opt_l) {
	Usage "Missing pkgname";
}

if ($opt_l && @ARGV != 0) {
	Usage "No pkgnames after -l";
}

setup_state();

# Here we create the list of packages to install
# actually, an updateset list (@todo2), and we hope to do this lazily
# later for the most part...
my @todo2 = ();

if ($opt_l) {
	open my $f, '<', $opt_l or die "$!: bad list $opt_l";
	my $_;
	while (<$f>) {
		chomp;
		s/\s.*//;
		push(@ARGV, $_);
	}
}

# three cases: 
# 1/ match fuzzily against a list
if ($opt_l || $opt_z) {

	$state->progress->set_header("Looking for packages");
	for my $_ (@ARGV) {
		my $set = OpenBSD::UpdateSet->new->add_hints($_);
		if ($state->updater->process_hint($set, $_, $state)) {
			push(@todo2, $set);
		}
	}
# 2/ update existing stuff
} elsif ($opt_u) {
	require OpenBSD::PackageRepository::Installed;

	if (@ARGV == 0) {
		@ARGV = sort(installed_packages());
		$state->{full_update} = 1;
	}
	my $inst = OpenBSD::PackageRepository::Installed->new;
	$state->progress->set_header("Looking for updates");
	for my $pkgname (@ARGV) {
		my $l;

		if (OpenBSD::PackageName::is_stem($pkgname)) {
			$l = stem2location($inst, $pkgname, $state);
 		} else {
			$l = $inst->find($pkgname, $state->{arch});
		}
		if (!defined $l) {
			$state->say("Problem finding $pkgname");
		} else {
			my $set = OpenBSD::UpdateSet->new->add_older(OpenBSD::Handle->from_location($l));
			my $problem = 0;
			for my $l ($set->older) {
				(defined $state->updater->process_handle($set, $l, $state)) or $problem = 1;
			}
			if ($set->newer > 0) {
				push(@todo2, $set);
			} else {
				$state->tracker->mark_uptodate($set);
			}
			if ($problem) {
				$state->tracker->mark_cant_update($set);
			}
		}
	}
	$state->progress->next;

	my @cantupdate = $state->tracker->cant_update;
	if (@cantupdate > 0) {
		$state->print("Cannot find updates for ", join(', ', (@cantupdate > 50 ? @cantupdate[1..50] : @cantupdate)));
		print " and more" if @cantupdate > 50;
		print "\n";
		if (@todo2 == 0) {
			print "No updates found\n";
			exit(1);
		}
		if ($state->{defines}->{alwaysupdate} ||
		    $state->{full_update} && !$state->{interactive}) {
			print "Proceeding anyways\n";
		} else {
			if (!OpenBSD::Interactive::confirm("Proceed", 
			    $state->{interactive}, 0)) {
				exit(1);
			}
	    	}
	}
	if (defined $state->{issues}) {
		$state->say("There are some ambiguities. ",
		    "Please run in interactive mode again.");
	}
	$state->say("Running update ", 
	    join(',', map {$_->short_print} @todo2));
} else {
# 3/ actual names
	find_truelocations(\@ARGV, \@todo2, $state);
	OpenBSD::Add::tag_user_packages(@todo2);
}


my $dielater = do_the_main_work(
sub {
	# This is the actual very small loop that adds all packages
	$state->tracker->add_sets(@todo2);
	while (my $set = shift @todo2) {
		unshift(@todo2, install_set($set, $state));
	}
});

OpenBSD::Add::manpages_index($state);


# and display delayed thingies.
if ($state->{packages_with_sig}) {
	$state->print("Packages with signatures: ", $state->{packages_with_sig});
	if ($state->{packages_without_sig}) {
		print ". UNSIGNED PACKAGES: ", join(', ', keys %{$state->{packages_without_sig}});
	}
	print "\n";
}
if (defined $state->{updatedepends} && %{$state->{updatedepends}}) {
	print "Forced updates, bogus dependencies for ", 
	    join(' ', sort(keys %{$state->{updatedepends}})),
	    " may remain\n";
}

# show any error, and show why we died...
rethrow $dielater;
} catch {
	print STDERR "$0: $_\n";
	if ($_ =~ m/^Caught SIG(\w+)/o) {
		kill $1, $$;
	}
	exit(1);
};

if ($bad) {
	exit(1);
}

